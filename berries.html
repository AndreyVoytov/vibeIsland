<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>Berries (final + visible on bush)</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:transparent}
  canvas{display:block;position:absolute;top:0;left:0;pointer-events:none;background:transparent}
</style>
</head>
<body>
<canvas id="berriesCanvas"></canvas>

<!-- конфиг ягод -->
<script src="./berries-config.js"></script>
<script src="./buildings-config.js"></script>

<script>
/* =========================
   конфиг / выбор ягоды
========================= */
function pickWeightedBerryIndex(list, getW){
  let sum = 0;
  for(let i=0;i<list.length;i++) sum += Math.max(0, +getW(i) || 0);
  if(sum <= 0) return 0;
  let r = Math.random() * sum;
  for(let i=0;i<list.length;i++){
    r -= Math.max(0, +getW(i) || 0);
    if(r <= 0) return i;
  }
  return list.length - 1;
}

const BERRIES_LIST = (window.BerriesConfig && Array.isArray(window.BerriesConfig.berries)) ? window.BerriesConfig.berries : [];

const svgDataUri = (svg) => `data:image/svg+xml;utf8,${encodeURIComponent(svg)}`;

function buildResourceFallback(def){
  const primitive = def.primitive || {};
  let svg = "<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'>";
  if(primitive.kind === 'mushroom'){
    svg += `<rect x='10' y='34' width='44' height='20' rx='10' fill='${primitive.stem || '#e1d2bf'}'/>`;
    svg += `<path d='M12 34c4-14 36-14 40 0' fill='${primitive.cap || '#f4eee6'}'/>`;
    svg += `<circle cx='24' cy='28' r='4' fill='${primitive.spots || 'rgba(255,255,255,0.8)'}'/>`;
    svg += `<circle cx='40' cy='26' r='3' fill='${primitive.spots || 'rgba(255,255,255,0.8)'}'/>`;
  } else if(primitive.kind === 'beet'){
    svg += `<circle cx='32' cy='36' r='14' fill='${primitive.root || '#9b1b30'}'/>`;
    svg += `<path d='M32 14c6 2 10 6 12 12-6-2-14-2-24 0 2-6 6-10 12-12z' fill='${primitive.leaf || '#2f9b52'}'/>`;
    svg += `<circle cx='26' cy='32' r='4' fill='${primitive.highlight || 'rgba(255,255,255,0.4)'}'/>`;
  } else if(primitive.kind === 'tree'){
    const trunk = primitive.trunk || '#6d4a2f';
    const foliage = primitive.foliage || '#2f7b3d';
    const accent = primitive.accent || '#4aa25e';
    if(primitive.form === 'pine'){
      svg += `<rect x='29' y='32' width='6' height='18' rx='2' fill='${trunk}'/>`;
      svg += `<path d='M32 8 L14 34 L50 34 Z' fill='${foliage}'/>`;
      svg += `<path d='M32 16 L18 36 L46 36 Z' fill='${accent}' opacity='0.9'/>`;
    } else {
      svg += `<rect x='28' y='34' width='8' height='18' rx='2' fill='${trunk}'/>`;
      svg += `<circle cx='32' cy='26' r='18' fill='${foliage}'/>`;
      svg += `<circle cx='24' cy='20' r='10' fill='${accent}' opacity='0.9'/>`;
    }
  } else if(primitive.kind === 'log'){
    const bark = primitive.bark || '#6d4a2f';
    const core = primitive.core || '#c89a5b';
    svg += `<rect x='10' y='26' width='44' height='12' rx='6' fill='${bark}'/>`;
    svg += `<circle cx='16' cy='32' r='6' fill='${core}'/>`;
    svg += `<circle cx='48' cy='32' r='6' fill='${core}'/>`;
    svg += `<circle cx='16' cy='32' r='3' fill='rgba(255,255,255,0.35)'/>`;
  } else {
    svg += `<circle cx='32' cy='32' r='20' fill='${primitive.base || '#e11'}'/>`;
    svg += `<circle cx='24' cy='26' r='6' fill='${primitive.highlight || 'rgba(255,255,255,0.5)'}'/>`;
  }
  svg += '</svg>';
  return svgDataUri(svg);
}

function getBerryAssetUrl(def){
  if(def && def.assetUrl) return def.assetUrl;
  if(!def) return '';
  if(!def.__fallbackUrl){
    def.__fallbackUrl = buildResourceFallback(def);
  }
  return def.__fallbackUrl;
}

const getResourceWeight = (window.BerriesConfig && typeof window.BerriesConfig.getResourceWeight === 'function')
  ? window.BerriesConfig.getResourceWeight
  : (/*index*/)=>1;

function getUserState(){
  let user = {};
  try {
    user = JSON.parse(localStorage.getItem('user') || '{}');
  } catch (err) {
    user = {};
  }
  if(typeof user.money !== 'number' || Number.isNaN(user.money)){
    user.money = 0;
  }
  if(!user.unlockedResources || typeof user.unlockedResources !== 'object'){
    user.unlockedResources = {};
  }
  if(!Object.values(user.unlockedResources).some(Boolean) && BERRIES_LIST[0]){
    user.unlockedResources[BERRIES_LIST[0].id] = true;
  }
  localStorage.setItem('user', JSON.stringify(user));
  return user;
}

function setUserState(user){
  localStorage.setItem('user', JSON.stringify(user));
}

function getUnlockedResourceIds(){
  const user = getUserState();
  return Object.keys(user.unlockedResources).filter((id)=>user.unlockedResources[id]);
}

function getResourceProfitById(id){
  const found = BERRIES_LIST.find((entry)=>entry.id === id);
  if(found && typeof found.profit === 'number') return found.profit;
  return 1;
}
  
/* =========================
   1) ассеты куст/листья (опционально)
========================= */
const DEFAULT_BUSH_ASSET_URL = '';
const LEAF_ASSET_URL  = '';

const useLeafImg = LEAF_ASSET_URL.includes('images');
const leafImg = useLeafImg ? new Image() : null;
let leafImgOk = false;

function wireImg(img, setOk){
  if(!img) return;
  img.onload = () => setOk(true);
  img.onerror = () => setOk(false);
}
wireImg(leafImg, v=>leafImgOk=v);
if (leafImg) leafImg.src = LEAF_ASSET_URL;

function canDrawImg(img){
  return !!img && img.complete && img.naturalWidth > 0 && img.naturalHeight > 0;
}

/* =========================
   2) кэш картинок ягод/кустов
========================= */
const berryImgCache = new Map(); // url -> {img, ok}
function getBerryImgRec(url){
  if(!url) return null; // строго по правилу
  let rec = berryImgCache.get(url);
  if(rec) return rec;
  const img = new Image();
  rec = { img, ok:false };
  img.onload = () => { rec.ok = true; };
  img.onerror = () => { rec.ok = false; };
  img.src = url;
  berryImgCache.set(url, rec);
  return rec;
}

const bushImgCache = new Map(); // url -> {img, ok}
function getBushImgRec(url){
  if(!url) return null;
  let rec = bushImgCache.get(url);
  if(rec) return rec;
  const img = new Image();
  rec = { img, ok:false };
  img.onload = () => { rec.ok = true; };
  img.onerror = () => { rec.ok = false; };
  img.src = url;
  bushImgCache.set(url, rec);
  return rec;
}

/* =========================
   3) выбор ягоды по весам
========================= */
function pickWeightedIndex(list, getW){
  let sum = 0;
  for(let i=0;i<list.length;i++) sum += Math.max(0, +getW(i) || 0);
  if(sum <= 0) return 0;
  let r = Math.random() * sum;
  for(let i=0;i<list.length;i++){
    r -= Math.max(0, +getW(i) || 0);
    if(r <= 0) return i;
  }
  return list.length - 1;
}
function pickBerryDef(){
  if(!BERRIES_LIST.length) return {
    id:'fallback', titleRu:'Ягода', assetUrl:'', widthPx:24, heightPx:24,
    primitive:{base:'#e11', highlight:'rgba(255,255,255,0.6)'}
  };
  const unlocked = new Set(getUnlockedResourceIds());
  const available = BERRIES_LIST.filter((def)=>unlocked.has(def.id));
  const pool = available.length ? available : BERRIES_LIST;
  const idx = pickWeightedIndex(pool, (i) => {
    const originalIndex = BERRIES_LIST.indexOf(pool[i]);
    return getResourceWeight(originalIndex >= 0 ? originalIndex : i);
  });
  return pool[idx] || pool[0];
}

/* =========================
   4) баланс/константы
========================= */
const SPAWN_MS = 1000, BURST_R_PCT = 12, PICK_R_PCT = 8, PICK_COOLDOWN_MS = 1;
const BUSH_GROW_MS = 1000, BERRIES_GROW_MS = 100, BERRIES_MIN_MAX = [6,9];
const SCATTER_MIN_PCT = 5, SCATTER_MAX_PCT = 13, BERRY_FLY_MS = 200;
const LEAF_COUNT = 28, LEAF_LIFE_MS = 700, LEAF_SPD_MIN = 6, LEAF_SPD_MAX = 10;
const BERRY_R_PCT = 1.2, BUSH_R_PCT = 3.7;
const BUSH_TOP_GROW_MULT = 1.2;
const PICK_OUT_MS = 200, PICK_IN_MS = 200, PICK_OUT_DIST_PCT = 1;
const PICK_TARGET_UP_CELLS = 2.2;
const DEFAULT_MIN_SPAWN_RADIUS = 0;
const DEFAULT_MAX_SPAWN_RADIUS = 10;
const EXTRACT_PARTICLE_COUNT = 3;
const RESOURCE_COLLIDER_PADDING = 1;
const RESOURCE_FARMING_PADDING = RESOURCE_COLLIDER_PADDING + 1;
const COLLIDER_SPAWN_HERO_BUFFER_CELLS = 2;
const OFFLINE_FILL_WINDOW_MS = 60 * 60 * 1000;
const RESOURCE_LAST_SEEN_KEY = 'resourceLastSeenAt';

/* хитбокс ног героя */
const HERO_PIVOT = { left: 1.7, right: 1.7, up: 4, down: -0.5 };

/* утилиты */
const rnd=(a,b)=>a+Math.random()*(b-a), rndi=(a,b)=>Math.floor(rnd(a,b+1));
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v)), vec=a=>({x:Math.cos(a),y:Math.sin(a)});
const outBack=t=>{const c1=1.70158,c3=c1+1;return 1+c3*(t-1)**3+c1*(t-1)**2;};
const outCub=t=>1-(1-t)**3, lerp=(a,b,t)=>a+(b-a)*t;
function getCam(){ return JSON.parse(localStorage.getItem('camera') || '{"x":0,"y":0}'); }

/* карта / герой */
let map = [];
let GRID_W = 0;
function getHero(){ return JSON.parse(localStorage.getItem('heroState') || '{"charXPct":50,"charYPct":50,"facing":1,"isMoving":false}'); }
const buildingsConfig = window.BuildingsConfig || { buildings: [], getBuildingLayout: () => [] };
let buildingLayout = [];
let campfireCenter = null;
const buildingDefs = buildingsConfig.buildings || [];
const buildingById = new Map(buildingDefs.map((item) => [item.id, item]));

function getVirtualCellPx(){
  const value = buildingsConfig.virtualCellPx;
  return Number.isFinite(value) ? value : 28;
}

function getExpansionLevel(){
  const stored = Number(localStorage.getItem('islandExpansionLevel') || '0');
  if(!Number.isFinite(stored)) return 0;
  return Math.max(0, Math.floor(stored));
}

function getBaseGridW(){
  const stored = Number(localStorage.getItem('baseGridW') || '0');
  if(Number.isFinite(stored) && stored > 0) return stored;
  if(GRID_W){
    localStorage.setItem('baseGridW', String(GRID_W));
    return GRID_W;
  }
  return 0;
}

function getCellPx(){
  const vw = parseFloat(localStorage.getItem('gameWidth')) || innerWidth;
  const baseGridW = getBaseGridW();
  if(!baseGridW) return 0;
  const scale = Math.pow(0.97, getExpansionLevel());
  return (vw / baseGridW) * scale;
}

function getWorldWidth(){
  const cell = getCellPx();
  return (cell && GRID_W) ? cell * GRID_W : (parseFloat(localStorage.getItem('gameWidth')) || innerWidth);
}

function getBuildingAnchorSpot(layout){
  const anchorSpot = layout.find((spot) => spot.id === 'campfire');
  if(anchorSpot) return anchorSpot;
  const gridH = map.length || 0;
  if(GRID_W && gridH){
    return { x: (GRID_W * 0.5) - 0.5, y: (gridH * 0.5) - 0.5 };
  }
  return null;
}

function getActiveBuildingCells(padding = 0){
  const user = getUserState();
  const cells = new Set();
  if(!Array.isArray(buildingLayout) || !GRID_W) return cells;
  const anchorSpot = getBuildingAnchorSpot(buildingLayout);
  const cellPx = getCellPx();
  if(!anchorSpot || !cellPx) return cells;
  const virtualCellPx = getVirtualCellPx();
  const anchorX = (anchorSpot.x + 0.5) * cellPx;
  const anchorY = (anchorSpot.y + 0.5) * cellPx;
  buildingLayout.forEach((spot) => {
    const def = buildingById.get(spot.id);
    if(!def) return;
    const unlocked = def.defaultUnlocked || user.unlockedResources[def.id];
    if(!unlocked) return;
    const radius = Number.isFinite(def.colliderRadius) ? def.colliderRadius : 1;
    const centerX = anchorX + (spot.x - anchorSpot.x) * virtualCellPx;
    const centerY = anchorY + (spot.y - anchorSpot.y) * virtualCellPx;
    const gridX = Math.floor(centerX / cellPx);
    const gridY = Math.floor(centerY / cellPx);
    const radiusCells = Math.max(1, Math.round((radius * virtualCellPx) / cellPx));
    const expanded = Math.max(0, radiusCells + Math.max(0, Math.round(padding)));
    for(let dy = -expanded; dy <= expanded; dy += 1){
      for(let dx = -expanded; dx <= expanded; dx += 1){
        cells.add(`${gridX + dx},${gridY + dy}`);
      }
    }
  });
  return cells;
}

function getSpawnRadius(def){
  const minSpawnRadius = Number.isFinite(def?.minSpawnRadius) ? def.minSpawnRadius : DEFAULT_MIN_SPAWN_RADIUS;
  const maxSpawnRadius = Number.isFinite(def?.maxSpawnRadius) ? def.maxSpawnRadius : DEFAULT_MAX_SPAWN_RADIUS;
  const safeMin = Math.max(0, minSpawnRadius);
  const safeMax = Math.max(safeMin, maxSpawnRadius);
  return { min: safeMin, max: safeMax };
}

function getHeroGridPosition(){
  if(!GRID_W || !cellPct) return null;
  const hero = getHero();
  const gridX = Math.floor(hero.charXPct / cellPct);
  const gridY = Math.floor(hero.charYPct / cellPct);
  if(!Number.isFinite(gridX) || !Number.isFinite(gridY)) return null;
  return { gridX, gridY };
}

let scenarioBlockersCache = new Set();
let scenarioBlockersUpdatedAt = 0;

function getScenarioBlockers(){
  const updatedAt = Number(localStorage.getItem('scenarioColliderUpdatedAt') || 0);
  if(updatedAt && updatedAt === scenarioBlockersUpdatedAt){
    return scenarioBlockersCache;
  }
  scenarioBlockersUpdatedAt = updatedAt;
  const raw = localStorage.getItem('scenarioColliderCells');
  if(!raw){
    scenarioBlockersCache = new Set();
    return scenarioBlockersCache;
  }
  try {
    const parsed = JSON.parse(raw);
    scenarioBlockersCache = new Set(Array.isArray(parsed) ? parsed : []);
  } catch (err) {
    scenarioBlockersCache = new Set();
  }
  return scenarioBlockersCache;
}

function getIslandBoundsCells(landCells){
  if(!landCells.length) return null;
  let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
  landCells.forEach(({x,y})=>{if(x<minX)minX=x;if(y<minY)minY=y;if(x>maxX)maxX=x;if(y>maxY)maxY=y;});
  return { minX, minY, maxX, maxY };
}

function resolveCampfireCenter(){
  const campfireSpot = buildingLayout.find((spot) => spot.id === 'campfire');
  if(campfireSpot){
    const offset = buildingsConfig.layoutOffset || { x: 0, y: 0 };
    const offsetX = Number.isFinite(offset.x) ? offset.x : 0;
    const offsetY = Number.isFinite(offset.y) ? offset.y : 0;
    return { x: campfireSpot.x - offsetX, y: campfireSpot.y - offsetY };
  }
  const bounds = getIslandBoundsCells(land);
  if(bounds){
    return { x: (bounds.minX + bounds.maxX) / 2, y: (bounds.minY + bounds.maxY) / 2 };
  }
  return null;
}

/* канвас */
const cvs=document.getElementById('berriesCanvas'),ctx=cvs.getContext('2d');
let cw=0,ch=0; const pct2px=p=>p*getWorldWidth()/100;
function resize(){
  const dpr = window.devicePixelRatio || 1;
  const width = innerWidth;
  const height = innerHeight;
  cvs.style.width = `${width}px`;
  cvs.style.height = `${height}px`;
  cvs.width = Math.round(width * dpr);
  cvs.height = Math.round(height * dpr);
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  cw = width;
  ch = height;
}
addEventListener('resize',resize); resize();

/* геометрия острова */
const TARGET_BUSHES_AT_CURRENT_MAP = 30;
let land = [];
let landSet = new Set();
let BUSH_DENSITY = 0.05;
let MAX_UNPICKED_BUSHES = 1;
let cellPct = 0;
const center=(x,y)=>({xPct:(x+0.5)*cellPct, yPct:(y+0.5)*cellPct});
function getHeroRect(hxPct,hyPct){ return { left: hxPct-HERO_PIVOT.left*cellPct, right: hxPct+HERO_PIVOT.right*cellPct, top: hyPct-HERO_PIVOT.up*cellPct, bottom: hyPct+HERO_PIVOT.down*cellPct }; }
function isInHeroRect(xPct,yPct,hxPct,hyPct){ const r=getHeroRect(hxPct,hyPct); return (xPct>=r.left && xPct<=r.right && yPct>=r.top && yPct<=r.bottom); }
function bushTouchesHero(bxPct,byPct,hxPct,hyPct,radPct=BUSH_R_PCT){
  const r=getHeroRect(hxPct,hyPct);
  const cx=Math.max(r.left,Math.min(r.right,bxPct));
  const cy=Math.max(r.top,Math.min(r.bottom,byPct));
  const dx=pct2px(bxPct-cx), dy=pct2px(byPct-cy);
  return Math.hypot(dx,dy)<=pct2px(radPct);
}
let islandBounds = { minXPct: 0, maxXPct: 100, minYPct: 0, maxYPct: 100 };

function getIslandBounds(landCells, cellSize){
  if(!landCells.length) return { minXPct: 0, maxXPct: 100, minYPct: 0, maxYPct: 100 };
  let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
  landCells.forEach(({x,y})=>{if(x<minX)minX=x;if(y<minY)minY=y;if(x>maxX)maxX=x;if(y>maxY)maxY=y;});
  return { minXPct: minX*cellSize, maxXPct:(maxX+1)*cellSize, minYPct:minY*cellSize, maxYPct:(maxY+1)*cellSize };
}
function clampToIsland(xPct,yPct,radPct=0){ const b=islandBounds;
  return {
    xPct:Math.max(b.minXPct+radPct,Math.min(b.maxXPct-radPct,xPct)),
    yPct:Math.max(b.minYPct+radPct,Math.min(b.maxYPct-radPct,yPct))
  };
}

function cellKey(x, y){ return `${x},${y}`; }

function isLandCell(x, y){
  return landSet.has(cellKey(x, y));
}

function isAllowedLandCell(x, y, avoid){
  if(!isLandCell(x, y)) return false;
  if(avoid && avoid.has(cellKey(x, y))) return false;
  return true;
}

function findNearestLandCell(x, y, avoid, maxR = 8){
  if(isAllowedLandCell(x, y, avoid)) return { x, y };
  for(let r = 1; r <= maxR; r += 1){
    for(let dy = -r; dy <= r; dy += 1){
      for(let dx = -r; dx <= r; dx += 1){
        if(Math.abs(dx) !== r && Math.abs(dy) !== r) continue;
        const nx = x + dx;
        const ny = y + dy;
        if(isAllowedLandCell(nx, ny, avoid)) return { x: nx, y: ny };
      }
    }
  }
  return null;
}

function clampToLandSafe(xPct, yPct, radPct = 0, avoid = null){
  if(!cellPct || !GRID_W) return clampToIsland(xPct, yPct, radPct);
  const clamped = clampToIsland(xPct, yPct, radPct);
  const gx = Math.floor(clamped.xPct / cellPct);
  const gy = Math.floor(clamped.yPct / cellPct);
  if(isAllowedLandCell(gx, gy, avoid)){
    return clamped;
  }
  const nearest = findNearestLandCell(gx, gy, avoid);
  if(!nearest) return clamped;
  return {
    xPct: (nearest.x + 0.5) * cellPct,
    yPct: (nearest.y + 0.5) * cellPct,
  };
}

/* =========================
   5) сущности
========================= */
const bushes=[], busy=new Set();
const resourceColliderCells = new Set();
const resourceSpawnCells = new Set();
let pendingResourceColliderSync = false;

function requestResourceColliderSync(){
  if(pendingResourceColliderSync) return;
  pendingResourceColliderSync = true;
  setTimeout(() => {
    pendingResourceColliderSync = false;
    localStorage.setItem('resourceColliderCells', JSON.stringify([...resourceColliderCells]));
    localStorage.setItem('resourceColliderUpdatedAt', String(Date.now()));
  }, 0);
}

function loadMapData({ initial = false } = {}){
  const parsed = JSON.parse(localStorage.getItem('map') || '[]');
  const nextMap = Array.isArray(parsed) ? parsed : [];
  const prevCellPct = cellPct;
  const prevGridW = GRID_W;
  map = nextMap;
  GRID_W = map[0]?.length || 0;
  cellPct = GRID_W ? (100/GRID_W) : 0;
  land = [];
  landSet = new Set();
  map.forEach((row,y)=>row.forEach((c,x)=>{ if(c){ land.push({x,y}); landSet.add(cellKey(x, y)); } }));
  BUSH_DENSITY = land.length ? (TARGET_BUSHES_AT_CURRENT_MAP / land.length) : 0.05;
  MAX_UNPICKED_BUSHES = Math.max(1, Math.round(land.length * BUSH_DENSITY));
  islandBounds = getIslandBounds(land, cellPct);
  buildingLayout = buildingsConfig.getBuildingLayout(map);
  campfireCenter = resolveCampfireCenter();

  if(!initial && prevGridW && GRID_W && prevCellPct){
    let shift = { x: 0, y: 0 };
    try {
      shift = JSON.parse(localStorage.getItem('mapShift') || '{"x":0,"y":0}');
    } catch (err) {
      shift = { x: 0, y: 0 };
    }
    const shiftX = Number.isFinite(shift.x) ? shift.x : 0;
    const shiftY = Number.isFinite(shift.y) ? shift.y : 0;
    if(shiftX || shiftY || prevCellPct !== cellPct){
      const nextBusy = new Set();
      bushes.forEach((b) => {
        const oldGridX = b.gridX;
        const oldGridY = b.gridY;
        const newGridX = oldGridX + shiftX;
        const newGridY = oldGridY + shiftY;
        const oldCenterX = (oldGridX + 0.5) * prevCellPct;
        const oldCenterY = (oldGridY + 0.5) * prevCellPct;
        const newCenterX = (newGridX + 0.5) * cellPct;
        const newCenterY = (newGridY + 0.5) * cellPct;
        const dx = newCenterX - oldCenterX;
        const dy = newCenterY - oldCenterY;
        b.gridX = newGridX;
        b.gridY = newGridY;
        b.xPct += dx;
        b.yPct += dy;
        b.berries.forEach((be) => {
          be.xPct += dx;
          be.yPct += dy;
          be.x0 += dx;
          be.y0 += dy;
          be.tx += dx;
          be.ty += dy;
        });
        b.leafs.forEach((leaf) => {
          leaf.xPct += dx;
          leaf.yPct += dy;
        });
        if(b.stage === 'growing' || b.stage === 'ripe'){
          nextBusy.add(`${b.gridX},${b.gridY}`);
        }
      });
      busy.clear();
      nextBusy.forEach((key) => busy.add(key));
      rebuildResourceColliderCells();
      rebuildResourceSpawnCells();
    }
  }
}
loadMapData({ initial: true });
fillOfflineResources();
addEventListener('beforeunload', markResourceSeen);
addEventListener('pagehide', markResourceSeen);
addEventListener('visibilitychange', () => {
  if(document.visibilityState === 'hidden'){
    markResourceSeen();
  }
});

function mkBerry(onBush,xPct,yPct,def){
  return {
    def,
    onBush, xPct, yPct,
    scale:0.01, t0:performance.now(), alive:true,
    x0:xPct,y0:yPct,tx:xPct,ty:yPct,
    flying:false,tFly0:0,flyDur:BERRY_FLY_MS,
    stage:'idle',tPick0:0,ux:0,uy:0
  };
}
function mkLeaf(xPct,yPct){
  const a=rnd(0,Math.PI*2), v=vec(a), spd=rnd(LEAF_SPD_MIN,LEAF_SPD_MAX);
  return { xPct,yPct, vxPct:v.x*spd, vyPct:v.y*spd, rot:rnd(0,Math.PI*2), angVel:rnd(-10,10)*(Math.PI/180), t0:performance.now() };
}

function isExtractable(def){
  return def && def.resourceType === 'extractable';
}

function getExtractStages(def){
  if(!def || !Array.isArray(def.extractStages) || !def.extractStages.length) return [1];
  return def.extractStages;
}

function getExtractHarvestMs(def){
  if(def && Number.isFinite(def.extractHarvestMs)) return def.extractHarvestMs;
  return 700;
}

function getResourceColliderBox(def, stageIndex = 0){
  if(!def || !def.collider) return null;
  if(Array.isArray(def.colliderBoxStages) && def.colliderBoxStages.length){
    const idx = clamp(stageIndex, 0, def.colliderBoxStages.length - 1);
    const stage = def.colliderBoxStages[idx] || {};
    const radiusX = Math.max(0, Math.round(Number.isFinite(stage.x) ? stage.x : stage.radiusX || stage[0] || 0));
    const radiusY = Math.max(0, Math.round(Number.isFinite(stage.y) ? stage.y : stage.radiusY || stage[1] || 0));
    return { radiusX, radiusY };
  }
  const radius = Number.isFinite(def.colliderRadius) ? def.colliderRadius : 1;
  const normalized = Math.max(1, Math.round(radius));
  return { radiusX: normalized, radiusY: normalized };
}

function collectColliderCells(gridX, gridY, radiusX, radiusY, padding = 0){
  const cells = [];
  const expandedX = Math.max(0, Math.round(radiusX) + Math.max(0, Math.round(padding)));
  const expandedY = Math.max(0, Math.round(radiusY) + Math.max(0, Math.round(padding)));
  for(let dy = -expandedY; dy <= expandedY; dy += 1){
    for(let dx = -expandedX; dx <= expandedX; dx += 1){
      cells.push(`${gridX + dx},${gridY + dy}`);
    }
  }
  return cells;
}

function getResourceColliderCells(gridX, gridY, def, stageIndex = 0, padding = 0){
  const box = getResourceColliderBox(def, stageIndex);
  if(!box) return [];
  return collectColliderCells(gridX, gridY, box.radiusX, box.radiusY, padding);
}

function heroTouchesResourceCollider(bush){
  if(!bush || !isExtractable(bush.berryDef)) return false;
  const heroPos = getHeroGridPosition();
  if(!heroPos) return false;
  const cells = getResourceColliderCells(
    bush.gridX,
    bush.gridY,
    bush.berryDef,
    typeof bush.extractStage === 'number' ? bush.extractStage : 0,
    RESOURCE_FARMING_PADDING,
  );
  if(!cells.length) return false;
  return cells.includes(`${heroPos.gridX},${heroPos.gridY}`);
}

function registerResourceCollider(bush){
  if(!bush || !isExtractable(bush.berryDef)) return;
  const cells = getResourceColliderCells(
    bush.gridX,
    bush.gridY,
    bush.berryDef,
    typeof bush.extractStage === 'number' ? bush.extractStage : 0,
    RESOURCE_COLLIDER_PADDING,
  );
  if(!cells.length) return;
  cells.forEach((key) => resourceColliderCells.add(key));
  bush.colliderCells = cells;
  requestResourceColliderSync();
}

function unregisterResourceCollider(bush){
  if(!bush || !Array.isArray(bush.colliderCells)) return;
  bush.colliderCells.forEach((key) => resourceColliderCells.delete(key));
  bush.colliderCells = null;
  requestResourceColliderSync();
}

function refreshResourceCollider(bush){
  if(!bush || !isExtractable(bush.berryDef)) return;
  unregisterResourceCollider(bush);
  registerResourceCollider(bush);
}

function getResourceSpawnCells(gridX, gridY, def, stageIndex = 0){
  if(isExtractable(def)){
    return getResourceColliderCells(gridX, gridY, def, stageIndex, RESOURCE_COLLIDER_PADDING);
  }
  return collectColliderCells(gridX, gridY, 0, 0, 0);
}

function registerResourceSpawn(bush){
  if(!bush) return;
  const cells = getResourceSpawnCells(
    bush.gridX,
    bush.gridY,
    bush.berryDef,
    typeof bush.extractStage === 'number' ? bush.extractStage : 0,
  );
  if(!cells.length) return;
  cells.forEach((key) => resourceSpawnCells.add(key));
  bush.spawnCells = cells;
}

function unregisterResourceSpawn(bush){
  if(!bush || !Array.isArray(bush.spawnCells)) return;
  bush.spawnCells.forEach((key) => resourceSpawnCells.delete(key));
  bush.spawnCells = null;
}

function refreshResourceSpawn(bush){
  if(!bush) return;
  unregisterResourceSpawn(bush);
  registerResourceSpawn(bush);
}

function rebuildResourceColliderCells(){
  resourceColliderCells.clear();
  bushes.forEach((b) => {
    if(!isExtractable(b.berryDef)) return;
    const cells = getResourceColliderCells(
      b.gridX,
      b.gridY,
      b.berryDef,
      typeof b.extractStage === 'number' ? b.extractStage : 0,
      RESOURCE_COLLIDER_PADDING,
    );
    if(!cells.length) return;
    cells.forEach((key) => resourceColliderCells.add(key));
    b.colliderCells = cells;
  });
  requestResourceColliderSync();
}

function rebuildResourceSpawnCells(){
  resourceSpawnCells.clear();
  bushes.forEach((b) => {
    if(b.stage === 'dead') return;
    registerResourceSpawn(b);
  });
}

function markResourceSeen(){
  localStorage.setItem(RESOURCE_LAST_SEEN_KEY, String(Date.now()));
}

function getOfflineFillRatio(){
  const lastSeen = Number(localStorage.getItem(RESOURCE_LAST_SEEN_KEY) || 0);
  if(!lastSeen) return 0;
  const elapsed = Math.max(0, Date.now() - lastSeen);
  return clamp(elapsed / OFFLINE_FILL_WINDOW_MS, 0, 1);
}

function getExtractStageScale(b){
  if(!b || !isExtractable(b.berryDef)) return 1;
  const stages = getExtractStages(b.berryDef);
  const idx = clamp(typeof b.extractStage === 'number' ? b.extractStage : 0, 0, stages.length - 1);
  return stages[idx] || 1;
}

function getExtractParticleDef(def){
  if(!def) return { id: 'log', widthPx: 20, heightPx: 12, primitive: { kind: 'log' } };
  if(def.__extractParticleDef) return def.__extractParticleDef;
  const primitive = def.primitive || {};
  if(primitive.kind === 'tree'){
    const bark = primitive.trunk || '#6d4a2f';
    def.__extractParticleDef = {
      id: def.id,
      widthPx: 20,
      heightPx: 12,
      primitive: {
        kind: 'log',
        bark,
        core: '#c89a5b',
      },
    };
  } else {
    def.__extractParticleDef = {
      id: def.id,
      widthPx: 18,
      heightPx: 18,
      primitive,
    };
  }
  return def.__extractParticleDef;
}

function getBushVisualDef(bush){
  const def = bush.berryDef || {};
  return {
    type: def.bushType || 'default',
    scale: typeof def.bushScale === 'number' ? def.bushScale : 1,
    assetUrl: def.bushAssetUrl || DEFAULT_BUSH_ASSET_URL,
    primitive: def.bushPrimitive || null,
  };
}

function spawnBush(berryDef){
  if(!land.length) return false;
  const spawnRadius = getSpawnRadius(berryDef);
  const extractable = isExtractable(berryDef);
  const buildingCells = getActiveBuildingCells(extractable ? RESOURCE_COLLIDER_PADDING : 0);
  const heroPos = extractable ? getHeroGridPosition() : null;
  const scenarioBlockers = getScenarioBlockers();

  for(let i=0;i<30;i++){
    const c=land[Math.random()*land.length|0], key=`${c.x},${c.y}`;
    if(campfireCenter){
      const dist = Math.hypot(c.x - campfireCenter.x, c.y - campfireCenter.y);
      if(dist < spawnRadius.min || dist > spawnRadius.max) continue;
    }
    if(heroPos){
      const distToHero = Math.hypot(c.x - heroPos.gridX, c.y - heroPos.gridY);
      if(distToHero <= COLLIDER_SPAWN_HERO_BUFFER_CELLS) continue;
    }
    if(buildingCells.has(key)) continue;
    if(scenarioBlockers.has(key)) continue;
    const spawnCells = getResourceSpawnCells(c.x, c.y, berryDef, 0);
    if(spawnCells.some((cell) => buildingCells.has(cell))) continue;
    if(spawnCells.some((cell) => scenarioBlockers.has(cell))) continue;
    if(spawnCells.some((cell) => resourceSpawnCells.has(cell))) continue;
    if(extractable && spawnCells.some((cell) => resourceColliderCells.has(cell))) continue;
    if(busy.has(key)) continue;
    busy.add(key);
    const bush = {
      gridX:c.x, gridY:c.y, ...center(c.x,c.y),
      stage:'growing', t0:performance.now(), scale:0,
      berries:[], leafs:[], berryDef
    };
    bushes.push(bush);
    registerResourceSpawn(bush);
    if(extractable){
      registerResourceCollider(bush);
    }
    return true;
  }
  return false;
}

function fillOfflineResources(){
  const ratio = getOfflineFillRatio();
  if(ratio <= 0){
    markResourceSeen();
    return;
  }
  const target = Math.round(MAX_UNPICKED_BUSHES * ratio);
  let active = bushes.filter(b=>b.stage==='growing'||b.stage==='ripe').length;
  let needed = Math.max(0, Math.min(MAX_UNPICKED_BUSHES - active, target - active));
  if(needed <= 0){
    markResourceSeen();
    return;
  }
  let attempts = 0;
  const maxAttempts = needed * 20;
  while(needed > 0 && attempts < maxAttempts){
    attempts += 1;
    const berryDef = pickBerryDef();
    if(spawnBush(berryDef)){
      needed -= 1;
      active += 1;
    }
  }
  markResourceSeen();
}

/* =========================
   6) спавн кустов
========================= */
setInterval(()=>{ if(!land.length) return;
  const unpicked=bushes.filter(b=>b.stage==='growing'||b.stage==='ripe').length;
  if(unpicked>=MAX_UNPICKED_BUSHES) return;
  const berryDef = pickBerryDef();
  spawnBush(berryDef);
}, SPAWN_MS);

/* =========================
   7) логика
========================= */
function updateFlyingParticles(b, now){
  b.berries.forEach((be) => {
    if(!be.flying) return;
    const k = outCub(clamp((now - be.tFly0) / be.flyDur, 0, 1));
    be.xPct = be.x0 + (be.tx - be.x0) * k;
    be.yPct = be.y0 + (be.ty - be.y0) * k;
    if(k >= 1) be.flying = false;
  });
}

function spawnExtractParticles(b, now, avoidSet){
  const particleDef = getExtractParticleDef(b.berryDef);
  const count = Number.isFinite(b.berryDef?.extractParticleCount) ? b.berryDef.extractParticleCount : EXTRACT_PARTICLE_COUNT;
  for(let i = 0; i < count; i++){
    const a = rnd(0, Math.PI * 2);
    const d = rnd(SCATTER_MIN_PCT, SCATTER_MAX_PCT);
    const v = vec(a);
    const to = clampToLandSafe(b.xPct + v.x * d, b.yPct + v.y * d, BERRY_R_PCT, avoidSet);
    const be = mkBerry(false, b.xPct, b.yPct, particleDef);
    Object.assign(be, {
      x0: b.xPct,
      y0: b.yPct,
      tx: to.xPct,
      ty: to.yPct,
      flying: true,
      tFly0: now,
      flyDur: BERRY_FLY_MS,
      onBush: false,
      scale: 1,
    });
    b.berries.push(be);
  }
}

function updBush(b){
  const now=performance.now();

  if(b.stage==='growing'){
    b.scale = outBack(clamp((now-b.t0)/BUSH_GROW_MS,0,1));
    if(b.scale>=1){
      b.stage='ripe';
      if(isExtractable(b.berryDef)){
        b.extractStage = 0;
        b.harvestStart = 0;
        return;
      }
      const n=rndi(...BERRIES_MIN_MAX);

	  //Спавн с разными ягодами на кусте, оставим на потом
      //for(let i=0;i<n;i++){
      //  const a=rnd(0,Math.PI*2), r=rnd(0.3,0.8)*BUSH_R_PCT, v=vec(a);
      //  const def = pickBerryDef(); // ВАЖНО: выбор для каждой ягоды
      //  b.berries.push(mkBerry(true, b.xPct+v.x*r, b.yPct+v.y*r, def));
      //}
	  
      if(!b.berryDef) b.berryDef = pickBerryDef(); // <-- один раз на куст
      const bushType = b.berryDef && b.berryDef.bushType;

      for(let i=0;i<n;i++){
        if(bushType === 'centered'){
          b.berries.push(mkBerry(true, b.xPct, b.yPct, b.berryDef));
          continue;
        }
        const a=rnd(0,Math.PI*2), r=rnd(0.3,0.8)*BUSH_R_PCT, v=vec(a);
        b.berries.push(mkBerry(true, b.xPct+v.x*r, b.yPct+v.y*r, b.berryDef));
      }
    }
    return;
  }

  if(b.stage==='ripe'){
    if(isExtractable(b.berryDef)){
      updateFlyingParticles(b, now);
      const h = getHero();
      const dist = Math.hypot(pct2px(h.charXPct - b.xPct), pct2px(h.charYPct - b.yPct));
      const touch = heroTouchesResourceCollider(b)
        || bushTouchesHero(b.xPct, b.yPct, h.charXPct, h.charYPct, BUSH_R_PCT);
      const canHarvest = touch || dist <= pct2px(BURST_R_PCT);
      if(!canHarvest){
        b.harvestStart = 0;
        return;
      }
      if(!b.harvestStart) b.harvestStart = now;
      const harvestMs = getExtractHarvestMs(b.berryDef);
      if(now - b.harvestStart < harvestMs) return;

      {
        const buildingCells = getActiveBuildingCells();
        const scenarioBlockers = getScenarioBlockers();
        const avoidSet = new Set([...buildingCells, ...scenarioBlockers]);
        spawnExtractParticles(b, now, avoidSet);
      }
      localStorage.setItem('heroAction', JSON.stringify({chopAt: now}));

      const stages = getExtractStages(b.berryDef);
      b.extractStage = (typeof b.extractStage === 'number' ? b.extractStage : 0) + 1;
      b.harvestStart = 0;
      if(b.extractStage >= stages.length){
        b.stage = 'exploded';
        busy.delete(`${b.gridX},${b.gridY}`);
        unregisterResourceCollider(b);
      } else {
        refreshResourceCollider(b);
        refreshResourceSpawn(b);
      }
      return;
    }
    b.berries.forEach(be=>{ be.scale = clamp((now-be.t0)/BERRIES_GROW_MS,0,1); });

    const h=getHero();
    const dist=Math.hypot(pct2px(h.charXPct-b.xPct),pct2px(h.charYPct-b.yPct));
    const touch = bushTouchesHero(b.xPct,b.yPct,h.charXPct,h.charYPct,BUSH_R_PCT);

    if (touch || dist <= pct2px(BURST_R_PCT)) {
      for(let i=0;i<LEAF_COUNT;i++) b.leafs.push(mkLeaf(b.xPct,b.yPct));

      const tNow=now;
      b.berries.forEach(be=>{
        const a=rnd(0,Math.PI*2), d=rnd(SCATTER_MIN_PCT,SCATTER_MAX_PCT), v=vec(a);
        const buildingCells = getActiveBuildingCells();
        const scenarioBlockers = getScenarioBlockers();
        const avoidSet = new Set([...buildingCells, ...scenarioBlockers]);
        const to = clampToLandSafe(b.xPct+v.x*d, b.yPct+v.y*d, BERRY_R_PCT, avoidSet);
        Object.assign(be,{
          x0:be.xPct,y0:be.yPct, tx:to.xPct,ty:to.yPct,
          flying:true,tFly0:tNow,flyDur:BERRY_FLY_MS,
          onBush:false,scale:1
        });
      });

      b.stage='exploded';
      busy.delete(`${b.gridX},${b.gridY}`);

      // триггерим удар — heroAnimation сам проиграет, если не занят
      localStorage.setItem('heroAction', JSON.stringify({chopAt: now}));
    }
    return;
  }

  if(b.stage==='exploded'){
    b.leafs = b.leafs.filter(l=>{
      const dt=1/60;
      l.xPct += l.vxPct*dt; l.yPct += l.vyPct*dt; l.rot += l.angVel;
      return now-l.t0 < LEAF_LIFE_MS;
    });

    updateFlyingParticles(b, now);

    if(!b.leafs.length && b.berries.every(be=>!be.alive)) b.stage='dead';
  }
}

/* =========================
   8) подбор ягод
========================= */
let lastPickMs = 0;
function collectBerryInstant(be){
  if(!be || !be.alive) return;
  be.alive = false;
  be.stage = 'done';
  const total=(+localStorage.getItem('berriesCollected')||0)+1;
  localStorage.setItem('berriesCollected',total);
  const profit = getResourceProfitById(be.def && be.def.id);
  const user = getUserState();
  user.money = (user.money || 0) + profit;
  setUserState(user);
}

function collectUnderBuildings(){
  if(!cellPct) return;
  const buildingCells = getActiveBuildingCells();
  if(!buildingCells.size) return;

  bushes.forEach((b) => {
    const key = `${b.gridX},${b.gridY}`;
    if(!buildingCells.has(key)) return;
    if(b.stage === 'growing' || b.stage === 'ripe'){
      if(isExtractable(b.berryDef)){
        b.stage = 'dead';
        busy.delete(key);
        unregisterResourceCollider(b);
        unregisterResourceSpawn(b);
        return;
      }
      b.berries.forEach(collectBerryInstant);
      b.stage = 'dead';
      busy.delete(key);
      unregisterResourceSpawn(b);
    }
  });

  bushes.forEach((b) => {
    b.berries.forEach((be) => {
      if(!be.alive) return;
      const gx = Math.floor(be.xPct / cellPct);
      const gy = Math.floor(be.yPct / cellPct);
      if(buildingCells.has(`${gx},${gy}`)){
        collectBerryInstant(be);
      }
    });
  });
}

function collectLoop(){
  collectUnderBuildings();
  const now=performance.now(), hero=getHero();
  const hxPct=hero.charXPct, hyPct=hero.charYPct;
  const hx=pct2px(hxPct),  hy=pct2px(hyPct);
  const pickTargetYPct = hyPct - PICK_TARGET_UP_CELLS * cellPct;

  bushes.forEach(b=>b.berries.forEach(be=>{
    if(be.stage==='collectOut'){
      const u=clamp((now-be.tPick0)/PICK_OUT_MS,0,1);
      be.xPct = lerp(be.x0, be.x0 + be.ux*PICK_OUT_DIST_PCT*PICK_R_PCT, u);
      be.yPct = lerp(be.y0, be.y0 + be.uy*PICK_OUT_DIST_PCT*PICK_R_PCT, u);
      if(u>=1){ be.stage='collectIn'; be.tPick0=now; be.x0=be.xPct; be.y0=be.yPct; }
    }else if(be.stage==='collectIn'){
      const u=clamp((now-be.tPick0)/PICK_IN_MS,0,1);
      be.xPct = lerp(be.x0,hxPct,u); be.yPct = lerp(be.y0,pickTargetYPct,u);
      if(u>=1){
        be.alive=false; be.stage='done';
        const total=(+localStorage.getItem('berriesCollected')||0)+1;
        localStorage.setItem('berriesCollected',total);
        const profit = getResourceProfitById(be.def && be.def.id);
        const user = getUserState();
        user.money = (user.money || 0) + profit;
        setUserState(user);
      }
    }
  }));

  if(now-lastPickMs<PICK_COOLDOWN_MS) return;

  const cand = [];
  bushes.forEach(b=>b.berries.forEach(be=>{
    if(be.stage==='idle'&&be.alive&&!be.flying&&!be.onBush){
      const d=Math.hypot(pct2px(be.xPct)-hx,pct2px(be.yPct)-hy);
      const under = isInHeroRect(be.xPct,be.yPct,hxPct,hyPct);
      if(under || d<=pct2px(PICK_R_PCT)) cand.push({be,d});
    }
  }));
  if(!cand.length) return;

  cand.sort((a,b)=>a.d-b.d);
  const { be } = cand[0];
  lastPickMs = now;

  const ux=be.xPct-hxPct, uy=be.yPct-hyPct, len=Math.hypot(ux,uy)||1;
  be.ux=ux/len; be.uy=uy/len;

  be.stage='collectOut'; be.tPick0=now; be.x0=be.xPct; be.y0=be.yPct;
}

/* =========================
   9) рендер
========================= */
function getBushScale(stage, t0, now){
  if(stage !== 'growing') return 1;
  return outBack(clamp((now - t0) / BUSH_GROW_MS, 0, 1));
}

function getTopBushScale(stage, t0, now){
  if(stage !== 'growing') return 1;
  const grow = clamp(((now - t0) * BUSH_TOP_GROW_MULT) / BUSH_GROW_MS, 0, 1);
  return outBack(grow);
}

function getCenteredBushScale(now, b){
  const grow = clamp((now - b.t0) / BUSH_GROW_MS, 0, 1);
  return {
    sx: lerp(0.6, 1, outCub(grow)),
    sy: lerp(0.2, 1, outBack(grow)),
  };
}

function drawMushroomPrimitive(x, y, w, h, primitive){
  const cap = primitive.cap || '#f2e9dd';
  const capShade = primitive.capShade || '#d6c7b4';
  const stem = primitive.stem || '#e6d7c3';
  const grass = primitive.grass || '#1f8b45';
  const spots = primitive.spots || '#ffffff';
  const shadow = primitive.shadow || 'rgba(0,0,0,0.2)';

  ctx.save();
  ctx.fillStyle = shadow;
  ctx.beginPath();
  ctx.ellipse(x, y + h * 0.25, w * 0.4, h * 0.1, 0, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = grass;
  ctx.beginPath();
  ctx.ellipse(x, y + h * 0.32, w * 0.45, h * 0.13, 0, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = stem;
  ctx.beginPath();
  ctx.moveTo(x - w * 0.12, y - h * 0.05);
  ctx.lineTo(x + w * 0.12, y - h * 0.05);
  ctx.lineTo(x + w * 0.12, y + h * 0.23);
  ctx.lineTo(x - w * 0.12, y + h * 0.23);
  ctx.closePath();
  ctx.fill();

  ctx.fillStyle = cap;
  ctx.beginPath();
  ctx.ellipse(x, y - h * 0.1, w * 0.45, h * 0.32, 0, Math.PI, 0);
  ctx.fill();
  ctx.fillStyle = capShade;
  ctx.beginPath();
  ctx.ellipse(x, y - h * 0.02, w * 0.4, h * 0.24, 0, Math.PI, 0);
  ctx.fill();

  ctx.fillStyle = spots;
  ctx.beginPath(); ctx.arc(x - w * 0.2, y - h * 0.17, w * 0.04, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(x + w * 0.05, y - h * 0.2, w * 0.05, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(x + w * 0.22, y - h * 0.14, w * 0.035, 0, Math.PI * 2); ctx.fill();
  ctx.restore();
}

function drawTreePrimitive(x, y, w, h, primitive){
  const trunk = primitive.trunk || '#6d4a2f';
  const bark = primitive.bark || trunk;
  const foliage = primitive.foliage || '#2f7b3d';
  const accent = primitive.accent || '#4aa25e';

  ctx.save();
  if(primitive.form === 'pine'){
    ctx.fillStyle = trunk;
    ctx.fillRect(x - w * 0.08, y + h * 0.1, w * 0.16, h * 0.35);
    ctx.fillStyle = foliage;
    ctx.beginPath();
    ctx.moveTo(x, y - h * 0.45);
    ctx.lineTo(x - w * 0.45, y + h * 0.15);
    ctx.lineTo(x + w * 0.45, y + h * 0.15);
    ctx.closePath();
    ctx.fill();
    ctx.fillStyle = accent;
    ctx.beginPath();
    ctx.moveTo(x, y - h * 0.3);
    ctx.lineTo(x - w * 0.35, y + h * 0.2);
    ctx.lineTo(x + w * 0.35, y + h * 0.2);
    ctx.closePath();
    ctx.fill();
  } else {
    ctx.fillStyle = bark;
    ctx.fillRect(x - w * 0.09, y + h * 0.1, w * 0.18, h * 0.38);
    ctx.fillStyle = foliage;
    ctx.beginPath();
    ctx.ellipse(x, y - h * 0.05, w * 0.4, h * 0.35, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = accent;
    ctx.beginPath();
    ctx.ellipse(x - w * 0.2, y - h * 0.2, w * 0.2, h * 0.18, 0, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.restore();
}

function drawBeetPrimitive(x, y, w, h, primitive){
  const root = primitive.root || '#8a1227';
  const leaf = primitive.leaf || '#2f9b52';
  const grass = primitive.grass || '#1b7d3e';
  const shadow = primitive.shadow || 'rgba(0,0,0,0.2)';

  ctx.save();
  ctx.fillStyle = shadow;
  ctx.beginPath();
  ctx.ellipse(x, y + h * 0.25, w * 0.4, h * 0.1, 0, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = grass;
  ctx.beginPath();
  ctx.ellipse(x, y + h * 0.28, w * 0.45, h * 0.12, 0, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = root;
  ctx.beginPath();
  ctx.ellipse(x, y + h * 0.05, w * 0.28, h * 0.32, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(x, y + h * 0.35);
  ctx.lineTo(x - w * 0.08, y + h * 0.45);
  ctx.lineTo(x + w * 0.08, y + h * 0.45);
  ctx.closePath();
  ctx.fill();

  ctx.fillStyle = leaf;
  ctx.beginPath();
  ctx.moveTo(x, y - h * 0.1);
  ctx.quadraticCurveTo(x - w * 0.35, y - h * 0.35, x - w * 0.1, y - h * 0.45);
  ctx.quadraticCurveTo(x - w * 0.15, y - h * 0.25, x, y - h * 0.1);
  ctx.fill();

  ctx.beginPath();
  ctx.moveTo(x, y - h * 0.12);
  ctx.quadraticCurveTo(x + w * 0.35, y - h * 0.35, x + w * 0.1, y - h * 0.45);
  ctx.quadraticCurveTo(x + w * 0.15, y - h * 0.2, x, y - h * 0.12);
  ctx.fill();
  ctx.restore();
}

function drawBushCentered(b, now, visual){
  if(b.stage==='exploded'||b.stage==='dead') return;
  const { sx, sy } = getCenteredBushScale(now, b);
  const base = pct2px(BUSH_R_PCT);
  const scale = typeof visual.scale === 'number' ? visual.scale : 1;
  const extractScale = getExtractStageScale(b);
  const w = base * 6 * sx * scale * extractScale;
  const h = base * 5 * sy * scale * extractScale;
  const x = pct2px(b.xPct);
  const y = pct2px(b.yPct);
  const rec = getBushImgRec(visual.assetUrl);

  if(rec && rec.ok && canDrawImg(rec.img)){
    ctx.drawImage(rec.img, x - w / 2, y - h * 0.45, w, h);
    return;
  }

  const primitive = visual.primitive || {};
  if(primitive.kind === 'beet'){
    drawBeetPrimitive(x, y, w, h, primitive);
    return;
  }
  if(primitive.kind === 'tree'){
    drawTreePrimitive(x, y, w, h, primitive);
    return;
  }
  drawMushroomPrimitive(x, y, w, h, primitive);
}

function drawBushBottom(b, now, visual){
  if(b.stage==='exploded'||b.stage==='dead') return;
  const s = getBushScale(b.stage, b.t0, now);
  const rec = getBushImgRec(visual.assetUrl);

  if(rec && rec.ok && canDrawImg(rec.img)){
    ctx.drawImage(rec.img, pct2px(b.xPct)-60*s, pct2px(b.yPct)-50*s, 120*s, 100*s);
  }else{
    const r=pct2px(BUSH_R_PCT)*s;
    ctx.save();
    ctx.fillStyle='#145c2b';
    ctx.beginPath(); ctx.arc(pct2px(b.xPct),pct2px(b.yPct),r,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#197c3a';
    ctx.beginPath(); ctx.arc(pct2px(b.xPct)-0.3*r,pct2px(b.yPct)-0.2*r,0.8*r,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(pct2px(b.xPct)+0.35*r,pct2px(b.yPct)-0.1*r,0.75*r,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }
}

function drawBushTop(b, now){
  if(b.stage==='exploded'||b.stage==='dead') return;
  const visual = getBushVisualDef(b);
  const rec = getBushImgRec(visual.assetUrl);
  if(rec && rec.ok && canDrawImg(rec.img)) return;

  const s = getTopBushScale(b.stage, b.t0, now);
  const r = pct2px(BUSH_R_PCT) * s;
  ctx.save();
  ctx.fillStyle='#1a7b38';
  ctx.beginPath(); ctx.arc(pct2px(b.xPct)-0.2*r,pct2px(b.yPct)-0.35*r,0.82*r,0,Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(pct2px(b.xPct)+0.35*r,pct2px(b.yPct)-0.3*r,0.9*r,0,Math.PI*2); ctx.fill();
  ctx.restore();
}

function drawBerry(be){
  if(!be.alive && be.stage!=='collectOut' && be.stage!=='collectIn') return;
  if(be.onBush && be.def && be.def.bushType === 'centered') return;
  const s = be.onBush ? be.scale : 1;
  const def = be.def || { widthPx:24,heightPx:24,assetUrl:'',primitive:{base:'#e11',highlight:'rgba(255,255,255,0.6)'} };
  const monolithScale = def.bushType === 'centered' ? 1 / 2.5 : 1;

  const rec = getBerryImgRec(getBerryAssetUrl(def));
  if(rec && rec.ok && canDrawImg(rec.img)){
    const w = (def.widthPx || 24) * s * monolithScale;
    const h = (def.heightPx || 24) * s * monolithScale;
    ctx.drawImage(rec.img, pct2px(be.xPct)-w/2, pct2px(be.yPct)-h/2, w, h);
    return;
  }

  const r = pct2px(BERRY_R_PCT) * s * monolithScale;
  const primitive = def.primitive || {};
  if(primitive.kind === 'mushroom'){
    ctx.save();
    ctx.fillStyle = primitive.stem || '#e1d2bf';
    ctx.fillRect(pct2px(be.xPct)-r*0.2, pct2px(be.yPct)+r*0.05, r*0.4, r*0.5);
    ctx.fillStyle = primitive.cap || '#f4eee6';
    ctx.beginPath();
    ctx.ellipse(pct2px(be.xPct), pct2px(be.yPct)-r*0.1, r*0.7, r*0.5, 0, Math.PI, 0);
    ctx.fill();
    ctx.fillStyle = primitive.spots || 'rgba(255,255,255,0.85)';
    ctx.beginPath(); ctx.arc(pct2px(be.xPct)-r*0.2, pct2px(be.yPct)-r*0.2, r*0.12, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(pct2px(be.xPct)+r*0.15, pct2px(be.yPct)-r*0.18, r*0.1, 0, Math.PI * 2); ctx.fill();
    ctx.restore();
    return;
  }
  if(primitive.kind === 'beet'){
    ctx.save();
    ctx.fillStyle = primitive.root || '#9b1b30';
    ctx.beginPath();
    ctx.ellipse(pct2px(be.xPct), pct2px(be.yPct)+r*0.1, r*0.6, r*0.7, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = primitive.leaf || '#2f9b52';
    ctx.beginPath();
    ctx.moveTo(pct2px(be.xPct), pct2px(be.yPct)-r*0.1);
    ctx.lineTo(pct2px(be.xPct)-r*0.45, pct2px(be.yPct)-r*0.6);
    ctx.lineTo(pct2px(be.xPct)-r*0.1, pct2px(be.yPct)-r*0.55);
    ctx.closePath();
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(pct2px(be.xPct), pct2px(be.yPct)-r*0.1);
    ctx.lineTo(pct2px(be.xPct)+r*0.45, pct2px(be.yPct)-r*0.6);
    ctx.lineTo(pct2px(be.xPct)+r*0.1, pct2px(be.yPct)-r*0.55);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
    return;
  }
  ctx.save();
  ctx.fillStyle = (def.primitive && def.primitive.base) ? def.primitive.base : '#e11';
  ctx.beginPath(); ctx.arc(pct2px(be.xPct),pct2px(be.yPct),r,0,Math.PI*2); ctx.fill();
  ctx.fillStyle = (def.primitive && def.primitive.highlight) ? def.primitive.highlight : 'rgba(255,255,255,0.6)';
  ctx.beginPath(); ctx.arc(pct2px(be.xPct)-0.35*r,pct2px(be.yPct)-0.35*r,0.25*r,0,Math.PI*2); ctx.fill();
  ctx.restore();
}

function drawLeaf(l){
  const alpha=clamp(1-(performance.now()-l.t0)/LEAF_LIFE_MS,0,1);

  if(useLeafImg && leafImgOk && canDrawImg(leafImg)){
    ctx.save();
    ctx.globalAlpha=alpha;
    ctx.translate(pct2px(l.xPct),pct2px(l.yPct));
    ctx.rotate(l.rot);
    ctx.drawImage(leafImg,-14,-9,28,18);
    ctx.restore();
  }else{
    const w=pct2px(2), h=pct2px(1);
    ctx.save();
    ctx.globalAlpha=alpha;
    ctx.translate(pct2px(l.xPct),pct2px(l.yPct));
    ctx.rotate(l.rot);
    ctx.fillStyle='#1d8f46';
    ctx.beginPath();
    ctx.moveTo(-w/2,0); ctx.lineTo(0,-h/2); ctx.lineTo(w/2,0); ctx.lineTo(0,h/2);
    ctx.closePath(); ctx.fill();
    ctx.restore();
  }
}

/* =========================
   10) главный цикл
========================= */
function frame(){
  bushes.forEach(b=>b.stage!=='dead' && updBush(b));
  for(let i=bushes.length-1;i>=0;i--){
    if(bushes[i].stage !== 'dead') continue;
    unregisterResourceCollider(bushes[i]);
    unregisterResourceSpawn(bushes[i]);
    bushes.splice(i,1);
  }

  collectLoop();

  const cam = getCam();
  const wiggle = getWiggleOffset();
  const now = performance.now();
  ctx.clearRect(0,0,cw,ch);
  ctx.save();
  ctx.translate(-cam.x + wiggle.x, -cam.y + wiggle.y);
  bushes.forEach(b=>{
    const visual = getBushVisualDef(b);
    if(visual.type === 'centered'){
      drawBushCentered(b, now, visual);
    }else{
      drawBushBottom(b, now, visual);
    }
    b.leafs.forEach(drawLeaf);
    b.berries.forEach(drawBerry);
    if(visual.type !== 'centered'){
      drawBushTop(b, now);
    }
  });
  ctx.restore();

  requestAnimationFrame(frame);
}
frame();

function getWiggleOffset(){
  const start = Number(localStorage.getItem('islandWiggleAt') || 0);
  if(!start) return { x: 0, y: 0 };
  const duration = 3500;
  const elapsed = performance.now() - start;
  if(elapsed < 0 || elapsed > duration) return { x: 0, y: 0 };
  const t = elapsed / duration;
  const decay = 1 - t;
  const cell = getCellPx();
  return {
    x: Math.sin(t * Math.PI * 4) * cell * 0.12 * decay,
    y: Math.cos(t * Math.PI * 4) * cell * 0.08 * decay,
  };
}

window.addEventListener('storage', (event) => {
  if(event.key === 'map'){
    loadMapData();
  }
});
</script>
</body>
</html>
