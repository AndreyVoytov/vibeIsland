<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>Berries (final + visible on bush)</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:transparent}
  canvas{display:block;position:absolute;top:0;left:0;pointer-events:none;background:transparent}
</style>
</head>
<body>
<canvas id="berriesCanvas"></canvas>

<!-- конфиг ягод -->
<script src="./berries-config.js"></script>

<script>
/* =========================
   конфиг / выбор ягоды
========================= */
function pickWeightedBerryIndex(list, getW){
  let sum = 0;
  for(let i=0;i<list.length;i++) sum += Math.max(0, +getW(i) || 0);
  if(sum <= 0) return 0;
  let r = Math.random() * sum;
  for(let i=0;i<list.length;i++){
    r -= Math.max(0, +getW(i) || 0);
    if(r <= 0) return i;
  }
  return list.length - 1;
}

const BERRIES_LIST = (window.BerriesConfig && Array.isArray(window.BerriesConfig.berries)) ? window.BerriesConfig.berries : [];

const getResourceWeight = (window.BerriesConfig && typeof window.BerriesConfig.getResourceWeight === 'function')
  ? window.BerriesConfig.getResourceWeight
  : (/*index*/)=>1;
  
/* =========================
   1) ассеты куст/листья (опционально)
========================= */
const BUSH_ASSET_URL  = '';
const LEAF_ASSET_URL  = '';

const useBushImg = BUSH_ASSET_URL.includes('images');
const useLeafImg = LEAF_ASSET_URL.includes('images');

const bushImg = useBushImg ? new Image() : null;
const leafImg = useLeafImg ? new Image() : null;

let bushImgOk=false, leafImgOk=false;

function wireImg(img, setOk){
  if(!img) return;
  img.onload = () => setOk(true);
  img.onerror = () => setOk(false);
}
wireImg(bushImg, v=>bushImgOk=v);
wireImg(leafImg, v=>leafImgOk=v);

if (bushImg) bushImg.src = BUSH_ASSET_URL;
if (leafImg) leafImg.src = LEAF_ASSET_URL;

function canDrawImg(img){
  return !!img && img.complete && img.naturalWidth > 0 && img.naturalHeight > 0;
}

/* =========================
   2) кэш картинок ягод
========================= */
const berryImgCache = new Map(); // url -> {img, ok}
function getBerryImgRec(url){
  if(!url) return null; // строго по правилу
  let rec = berryImgCache.get(url);
  if(rec) return rec;
  const img = new Image();
  rec = { img, ok:false };
  img.onload = () => { rec.ok = true; };
  img.onerror = () => { rec.ok = false; };
  img.src = url;
  berryImgCache.set(url, rec);
  return rec;
}

/* =========================
   3) выбор ягоды по весам
========================= */
function pickWeightedIndex(list, getW){
  let sum = 0;
  for(let i=0;i<list.length;i++) sum += Math.max(0, +getW(i) || 0);
  if(sum <= 0) return 0;
  let r = Math.random() * sum;
  for(let i=0;i<list.length;i++){
    r -= Math.max(0, +getW(i) || 0);
    if(r <= 0) return i;
  }
  return list.length - 1;
}
function pickBerryDef(){
  if(!BERRIES_LIST.length) return {
    id:'fallback', titleRu:'Ягода', assetUrl:'', widthPx:24, heightPx:24,
    primitive:{base:'#e11', highlight:'rgba(255,255,255,0.6)'}
  };
  const idx = pickWeightedIndex(BERRIES_LIST, getResourceWeight);
  return BERRIES_LIST[idx] || BERRIES_LIST[0];
}

/* =========================
   4) баланс/константы
========================= */
const SPAWN_MS = 1000, BURST_R_PCT = 12, PICK_R_PCT = 8, PICK_COOLDOWN_MS = 1;
const BUSH_GROW_MS = 1000, BERRIES_GROW_MS = 100, BERRIES_MIN_MAX = [6,9];
const SCATTER_MIN_PCT = 5, SCATTER_MAX_PCT = 13, BERRY_FLY_MS = 200;
const LEAF_COUNT = 28, LEAF_LIFE_MS = 700, LEAF_SPD_MIN = 6, LEAF_SPD_MAX = 10;
const BERRY_R_PCT = 1.2, BUSH_R_PCT = 3.7;
const PICK_OUT_MS = 200, PICK_IN_MS = 200, PICK_OUT_DIST_PCT = 1;

/* хитбокс ног героя */
const HERO_PIVOT = { left: 1.7, right: 1.7, up: 4, down: -0.5 };

/* утилиты */
const rnd=(a,b)=>a+Math.random()*(b-a), rndi=(a,b)=>Math.floor(rnd(a,b+1));
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v)), vec=a=>({x:Math.cos(a),y:Math.sin(a)});
const outBack=t=>{const c1=1.70158,c3=c1+1;return 1+c3*(t-1)**3+c1*(t-1)**2;};
const outCub=t=>1-(1-t)**3, lerp=(a,b,t)=>a+(b-a)*t;
function getCam(){ return JSON.parse(localStorage.getItem('camera') || '{"x":0,"y":0}'); }

/* карта / герой */
const map = JSON.parse(localStorage.getItem('map') || '[]');
const GRID_W = map[0]?.length || 0;
function getHero(){ return JSON.parse(localStorage.getItem('heroState') || '{"charXPct":50,"charYPct":50,"facing":1,"isMoving":false}'); }

/* канвас */
const cvs=document.getElementById('berriesCanvas'),ctx=cvs.getContext('2d');
let cw=0,ch=0; const pct2px=p=>p*cw/100;
function resize(){cw=cvs.width=innerWidth;ch=cvs.height=innerHeight;} addEventListener('resize',resize); resize();

/* геометрия острова */
const land=[]; map.forEach((row,y)=>row.forEach((c,x)=>c&&land.push({x,y})));
const TARGET_BUSHES_AT_CURRENT_MAP = 30;
const BUSH_DENSITY = land.length ? (TARGET_BUSHES_AT_CURRENT_MAP / land.length) : 0.05;
const MAX_UNPICKED_BUSHES = Math.max(1, Math.round(land.length * BUSH_DENSITY));
const cellPct = GRID_W ? (100/GRID_W) : 0;
const center=(x,y)=>({xPct:(x+0.5)*cellPct, yPct:(y+0.5)*cellPct});
function getHeroRect(hxPct,hyPct){ return { left: hxPct-HERO_PIVOT.left*cellPct, right: hxPct+HERO_PIVOT.right*cellPct, top: hyPct-HERO_PIVOT.up*cellPct, bottom: hyPct+HERO_PIVOT.down*cellPct }; }
function isInHeroRect(xPct,yPct,hxPct,hyPct){ const r=getHeroRect(hxPct,hyPct); return (xPct>=r.left && xPct<=r.right && yPct>=r.top && yPct<=r.bottom); }
function bushTouchesHero(bxPct,byPct,hxPct,hyPct,radPct=BUSH_R_PCT){
  const r=getHeroRect(hxPct,hyPct);
  const cx=Math.max(r.left,Math.min(r.right,bxPct));
  const cy=Math.max(r.top,Math.min(r.bottom,byPct));
  const dx=pct2px(bxPct-cx), dy=pct2px(byPct-cy);
  return Math.hypot(dx,dy)<=pct2px(radPct);
}
const islandBounds=(()=>{ if(!land.length) return {minXPct:0,maxXPct:100,minYPct:0,maxYPct:100};
  let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
  land.forEach(({x,y})=>{if(x<minX)minX=x;if(y<minY)minY=y;if(x>maxX)maxX=x;if(y>maxY)maxY=y;});
  return {minXPct:minX*cellPct,maxXPct:(maxX+1)*cellPct,minYPct:minY*cellPct,maxYPct:(maxY+1)*cellPct};
})();
function clampToIsland(xPct,yPct,radPct=0){ const b=islandBounds;
  return {
    xPct:Math.max(b.minXPct+radPct,Math.min(b.maxXPct-radPct,xPct)),
    yPct:Math.max(b.minYPct+radPct,Math.min(b.maxYPct-radPct,yPct))
  };
}

/* =========================
   5) сущности
========================= */
const bushes=[], busy=new Set();

function mkBerry(onBush,xPct,yPct,def){
  return {
    def,
    onBush, xPct, yPct,
    scale:0.01, t0:performance.now(), alive:true,
    x0:xPct,y0:yPct,tx:xPct,ty:yPct,
    flying:false,tFly0:0,flyDur:BERRY_FLY_MS,
    stage:'idle',tPick0:0,ux:0,uy:0
  };
}
function mkLeaf(xPct,yPct){
  const a=rnd(0,Math.PI*2), v=vec(a), spd=rnd(LEAF_SPD_MIN,LEAF_SPD_MAX);
  return { xPct,yPct, vxPct:v.x*spd, vyPct:v.y*spd, rot:rnd(0,Math.PI*2), angVel:rnd(-10,10)*(Math.PI/180), t0:performance.now() };
}

/* =========================
   6) спавн кустов
========================= */
setInterval(()=>{ if(!land.length) return;
  const unpicked=bushes.filter(b=>b.stage==='growing'||b.stage==='ripe').length;
  if(unpicked>=MAX_UNPICKED_BUSHES) return;

  for(let i=0;i<30;i++){
    const c=land[Math.random()*land.length|0], key=`${c.x},${c.y}`;
    if(busy.has(key)) continue;
    busy.add(key);
    bushes.push({
      gridX:c.x, gridY:c.y, ...center(c.x,c.y),
      stage:'growing', t0:performance.now(), scale:0,
      berries:[], leafs:[], berryDef:null
    });
    break;
  }
}, SPAWN_MS);

/* =========================
   7) логика
========================= */
function updBush(b){
  const now=performance.now();

  if(b.stage==='growing'){
    b.scale = outBack(clamp((now-b.t0)/BUSH_GROW_MS,0,1));
    if(b.scale>=1){
      b.stage='ripe';
      const n=rndi(...BERRIES_MIN_MAX);

	  //Спавн с разными ягодами на кусте, оставим на потом
      //for(let i=0;i<n;i++){
      //  const a=rnd(0,Math.PI*2), r=rnd(0.3,0.8)*BUSH_R_PCT, v=vec(a);
      //  const def = pickBerryDef(); // ВАЖНО: выбор для каждой ягоды
      //  b.berries.push(mkBerry(true, b.xPct+v.x*r, b.yPct+v.y*r, def));
      //}
	  
	  if(!b.berryDef) b.berryDef = pickBerryDef(); // <-- один раз на куст

	  for(let i=0;i<n;i++){
	    const a=rnd(0,Math.PI*2), r=rnd(0.3,0.8)*BUSH_R_PCT, v=vec(a);
	    b.berries.push(mkBerry(true, b.xPct+v.x*r, b.yPct+v.y*r, b.berryDef));
	  }
    }
    return;
  }

  if(b.stage==='ripe'){
    b.berries.forEach(be=>{ be.scale = clamp((now-be.t0)/BERRIES_GROW_MS,0,1); });

    const h=getHero();
    const dist=Math.hypot(pct2px(h.charXPct-b.xPct),pct2px(h.charYPct-b.yPct));
    const touch = bushTouchesHero(b.xPct,b.yPct,h.charXPct,h.charYPct,BUSH_R_PCT);

    if (touch || dist <= pct2px(BURST_R_PCT)) {
      for(let i=0;i<LEAF_COUNT;i++) b.leafs.push(mkLeaf(b.xPct,b.yPct));

      const tNow=now;
      b.berries.forEach(be=>{
        const a=rnd(0,Math.PI*2), d=rnd(SCATTER_MIN_PCT,SCATTER_MAX_PCT), v=vec(a);
        const to = clampToIsland(b.xPct+v.x*d, b.yPct+v.y*d, BERRY_R_PCT);
        Object.assign(be,{
          x0:be.xPct,y0:be.yPct, tx:to.xPct,ty:to.yPct,
          flying:true,tFly0:tNow,flyDur:BERRY_FLY_MS,
          onBush:false,scale:1
        });
      });

      b.stage='exploded';
      busy.delete(`${b.gridX},${b.gridY}`);

      // триггерим удар — heroAnimation сам проиграет, если не занят
      localStorage.setItem('heroAction', JSON.stringify({chopAt: now}));
    }
    return;
  }

  if(b.stage==='exploded'){
    b.leafs = b.leafs.filter(l=>{
      const dt=1/60;
      l.xPct += l.vxPct*dt; l.yPct += l.vyPct*dt; l.rot += l.angVel;
      return now-l.t0 < LEAF_LIFE_MS;
    });

    b.berries.forEach(be=>{
      if(be.flying){
        const k=outCub(clamp((now-be.tFly0)/be.flyDur,0,1));
        be.xPct=be.x0+(be.tx-be.x0)*k;
        be.yPct=be.y0+(be.ty-be.y0)*k;
        if(k>=1) be.flying=false;
      }
    });

    if(!b.leafs.length && b.berries.every(be=>!be.alive)) b.stage='dead';
  }
}

/* =========================
   8) подбор ягод
========================= */
let lastPickMs = 0;
function collectLoop(){
  const now=performance.now(), hero=getHero();
  const hxPct=hero.charXPct, hyPct=hero.charYPct;
  const hx=pct2px(hxPct),  hy=pct2px(hyPct);

  bushes.forEach(b=>b.berries.forEach(be=>{
    if(be.stage==='collectOut'){
      const u=clamp((now-be.tPick0)/PICK_OUT_MS,0,1);
      be.xPct = lerp(be.x0, be.x0 + be.ux*PICK_OUT_DIST_PCT*PICK_R_PCT, u);
      be.yPct = lerp(be.y0, be.y0 + be.uy*PICK_OUT_DIST_PCT*PICK_R_PCT, u);
      if(u>=1){ be.stage='collectIn'; be.tPick0=now; be.x0=be.xPct; be.y0=be.yPct; }
    }else if(be.stage==='collectIn'){
      const u=clamp((now-be.tPick0)/PICK_IN_MS,0,1);
      be.xPct = lerp(be.x0,hxPct,u); be.yPct = lerp(be.y0,hyPct,u);
      if(u>=1){
        be.alive=false; be.stage='done';
        const total=(+localStorage.getItem('berriesCollected')||0)+1;
        localStorage.setItem('berriesCollected',total);
      }
    }
  }));

  if(now-lastPickMs<PICK_COOLDOWN_MS) return;

  const cand = [];
  bushes.forEach(b=>b.berries.forEach(be=>{
    if(be.stage==='idle'&&be.alive&&!be.flying&&!be.onBush){
      const d=Math.hypot(pct2px(be.xPct)-hx,pct2px(be.yPct)-hy);
      const under = isInHeroRect(be.xPct,be.yPct,hxPct,hyPct);
      if(under || d<=pct2px(PICK_R_PCT)) cand.push({be,d});
    }
  }));
  if(!cand.length) return;

  cand.sort((a,b)=>a.d-b.d);
  const { be } = cand[0];
  lastPickMs = now;

  const ux=be.xPct-hxPct, uy=be.yPct-hyPct, len=Math.hypot(ux,uy)||1;
  be.ux=ux/len; be.uy=uy/len;

  be.stage='collectOut'; be.tPick0=now; be.x0=be.xPct; be.y0=be.yPct;
}

/* =========================
   9) рендер
========================= */
function drawBush(b){
  if(b.stage==='exploded'||b.stage==='dead') return;
  const s=b.stage==='growing'?b.scale:1;

  if(useBushImg && bushImgOk && canDrawImg(bushImg)){
    ctx.drawImage(bushImg, pct2px(b.xPct)-60*s, pct2px(b.yPct)-50*s, 120*s, 100*s);
  }else{
    const r=pct2px(BUSH_R_PCT)*s;
    ctx.save();
    ctx.fillStyle='#145c2b';
    ctx.beginPath(); ctx.arc(pct2px(b.xPct),pct2px(b.yPct),r,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#197c3a';
    ctx.beginPath(); ctx.arc(pct2px(b.xPct)-0.3*r,pct2px(b.yPct)-0.2*r,0.8*r,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(pct2px(b.xPct)+0.35*r,pct2px(b.yPct)-0.1*r,0.75*r,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }
}

function drawBerry(be){
  if(!be.alive && be.stage!=='collectOut' && be.stage!=='collectIn') return;
  const s = be.onBush ? be.scale : 1;
  const def = be.def || { widthPx:24,heightPx:24,assetUrl:'',primitive:{base:'#e11',highlight:'rgba(255,255,255,0.6)'} };

  const rec = getBerryImgRec(def.assetUrl);
  if(rec && rec.ok && canDrawImg(rec.img)){
    const w = (def.widthPx || 24) * s;
    const h = (def.heightPx || 24) * s;
    ctx.drawImage(rec.img, pct2px(be.xPct)-w/2, pct2px(be.yPct)-h/2, w, h);
    return;
  }

  const r = pct2px(BERRY_R_PCT) * s;
  ctx.save();
  ctx.fillStyle = (def.primitive && def.primitive.base) ? def.primitive.base : '#e11';
  ctx.beginPath(); ctx.arc(pct2px(be.xPct),pct2px(be.yPct),r,0,Math.PI*2); ctx.fill();
  ctx.fillStyle = (def.primitive && def.primitive.highlight) ? def.primitive.highlight : 'rgba(255,255,255,0.6)';
  ctx.beginPath(); ctx.arc(pct2px(be.xPct)-0.35*r,pct2px(be.yPct)-0.35*r,0.25*r,0,Math.PI*2); ctx.fill();
  ctx.restore();
}

function drawLeaf(l){
  const alpha=clamp(1-(performance.now()-l.t0)/LEAF_LIFE_MS,0,1);

  if(useLeafImg && leafImgOk && canDrawImg(leafImg)){
    ctx.save();
    ctx.globalAlpha=alpha;
    ctx.translate(pct2px(l.xPct),pct2px(l.yPct));
    ctx.rotate(l.rot);
    ctx.drawImage(leafImg,-14,-9,28,18);
    ctx.restore();
  }else{
    const w=pct2px(2), h=pct2px(1);
    ctx.save();
    ctx.globalAlpha=alpha;
    ctx.translate(pct2px(l.xPct),pct2px(l.yPct));
    ctx.rotate(l.rot);
    ctx.fillStyle='#1d8f46';
    ctx.beginPath();
    ctx.moveTo(-w/2,0); ctx.lineTo(0,-h/2); ctx.lineTo(w/2,0); ctx.lineTo(0,h/2);
    ctx.closePath(); ctx.fill();
    ctx.restore();
  }
}

/* =========================
   10) главный цикл
========================= */
function frame(){
  bushes.forEach(b=>b.stage!=='dead' && updBush(b));
  for(let i=bushes.length-1;i>=0;i--) if(bushes[i].stage==='dead') bushes.splice(i,1);

  collectLoop();

  const cam = getCam();
  ctx.clearRect(0,0,cw,ch);
  ctx.save();
  ctx.translate(-cam.x, -cam.y);
  bushes.forEach(b=>{
    drawBush(b);
    b.leafs.forEach(drawLeaf);
    b.berries.forEach(drawBerry);
  });
  ctx.restore();

  requestAnimationFrame(frame);
}
frame();
</script>
</body>
</html>
