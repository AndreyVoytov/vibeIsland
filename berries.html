<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>Berries (stable logs + fixed dead-condition)</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden;}
  canvas{display:block;position:absolute;top:0;left:0;touch-action:none}
</style>
</head>
<body>
<canvas id="berriesCanvas"></canvas>
<script>
/* ──────────────────── Настройки ассетов ──────────────────── */
const BUSH_ASSET_URL  = '';           // 'images/bush.png' — чтобы рисовать картинкой
const BERRY_ASSET_URL = '';
const LEAF_ASSET_URL  = '';

const useBushImg  = BUSH_ASSET_URL .includes('images');
const useBerryImg = BERRY_ASSET_URL.includes('images');
const useLeafImg  = LEAF_ASSET_URL .includes('images');

const bushImg  = useBushImg  ? new Image() : null;
const berryImg = useBerryImg ? new Image() : null;
const leafImg  = useLeafImg  ? new Image() : null;
if (bushImg ) bushImg .src = BUSH_ASSET_URL ;
if (berryImg) berryImg.src = BERRY_ASSET_URL;
if (leafImg ) leafImg .src = LEAF_ASSET_URL ;

/* ──────────────────── Константы баланса ──────────────────── */
const SPAWN_MS         = 1000;  // один куст в секунду
const BURST_R_PCT      = 12;    // радиус уничтожения куста
const PICK_R_PCT       = 8;     // радиус подбора ягоды
const PICK_COOLDOWN_MS = 1;   // ≥ 0.25 с между пикапами

const BUSH_GROW_MS    = 1000;
const BERRIES_GROW_MS = 100;
const BERRIES_MIN_MAX = [6,9];

const SCATTER_MIN_PCT = 3.0;
const SCATTER_MAX_PCT = 7.5;
const BERRY_FLY_MS    = 600;

const LEAF_COUNT    = 28;
const LEAF_LIFE_MS  = 700;
const LEAF_SPD_MIN  = 6;
const LEAF_SPD_MAX  = 10;

const BERRY_R_PCT = 1.2;
const BUSH_R_PCT  = 3.7;

/* ──────────────────── Утилиты ─────────────────────────────── */
const rnd =(a,b)=>a+Math.random()*(b-a);
const rndi=(a,b)=>Math.floor(rnd(a,b+1));
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const vec  = a=>({x:Math.cos(a), y:Math.sin(a)});
const outBack = t=>{ const c1=1.70158,c3=c1+1; return 1+c3*(t-1)**3+c1*(t-1)**2; };
const outCub  = t=>1-(1-t)**3;

/* ──────────────────── Карта и «Герой» ─────────────────────── */
const map = JSON.parse(localStorage.getItem('map') || '[]');
const GRID_W = map[0]?.length || 0;
function getHero(){
  return JSON.parse(localStorage.getItem('heroState')
    || '{"charXPct":50,"charYPct":50,"facing":1,"isMoving":false}');
}

/* ──────────────────── Канвас ──────────────────────────────── */
const cvs = document.getElementById('berriesCanvas');
const ctx = cvs.getContext('2d');
let cw=0,ch=0; const pct2px = p=>p*cw/100;
function onResize(){ cw=cvs.width=innerWidth; ch=cvs.height=innerHeight; }
addEventListener('resize',onResize); onResize();

/* ──────────────────── Геометрия карты ─────────────────────── */
const landCells=[];
map.forEach((row,y)=>row.forEach((cell,x)=>cell&&landCells.push({x,y})));
const cellPct = 100/GRID_W;
const center  = (x,y)=>({xPct:(x+0.5)*cellPct, yPct:(y+0.5)*cellPct});

/* ──────────────────── Сущности ────────────────────────────── */
const bushes = [];
const busy   = new Set();          // "x,y" клетка занята

function mkBerry(onBush,xPct,yPct){
  return { onBush, xPct, yPct, scale:0, alive:true,
           x0:xPct, y0:yPct, tx:xPct, ty:yPct,
           flying:false, tFly0:0, flyDur:BERRY_FLY_MS,
           t0:performance.now() };
}
function mkLeaf(xPct,yPct){
  const a=rnd(0,Math.PI*2), v=vec(a), spd=rnd(LEAF_SPD_MIN,LEAF_SPD_MAX);
  return { xPct, yPct, vxPct:v.x*spd, vyPct:v.y*spd,
           rot:rnd(0,Math.PI*2), angVel:rnd(-10,10)*(Math.PI/180),
           t0:performance.now() };
}

/* ──────────────────── Спавн кустов ────────────────────────── */
setInterval(()=>{
  if (!landCells.length) return;
  for(let i=0;i<30;i++){
    const c = landCells[Math.random()*landCells.length|0];
    const key = `${c.x},${c.y}`;
    if (busy.has(key)) continue;
    busy.add(key);
    bushes.push({
      gridX:c.x, gridY:c.y, ...center(c.x,c.y),
      stage:'growing', t0:performance.now(), scale:0,
      berries:[], leafs:[]
    });
    break;
  }
}, SPAWN_MS);

/* ──────────────────── Переменные логирования ──────────────── */
let lastHeroXPct=null, lastHeroYPct=null;
const HERO_EPS = 0.005;            // 0.005 % – считаем «сдвинулся»
let lastPickupMs = 0;

/* ──────────────────── Логика кустов ───────────────────────── */
function updateBush(b){
  const now = performance.now();
  /* growing */
  if (b.stage==='growing'){
    b.scale = outBack(clamp((now-b.t0)/BUSH_GROW_MS,0,1));
    if (b.scale >= 1){
      b.stage = 'ripe';
      const n = rndi(...BERRIES_MIN_MAX);
      for (let i=0;i<n;i++){
        const a=rnd(0,Math.PI*2), r=rnd(0.3,0.8)*BUSH_R_PCT, v=vec(a);
        const berr = mkBerry(true, b.xPct+v.x*r, b.yPct+v.y*r);
        berr.birthLen = BERRIES_GROW_MS;
        b.berries.push(berr);
      }
    }
    return;
  }

  /* ripe */
  if (b.stage==='ripe'){
    b.berries.forEach(be=>{
      be.scale = clamp((now-be.t0)/be.birthLen,0,1);
    });
    const h = getHero();
    const dist = Math.hypot(pct2px(h.charXPct-b.xPct), pct2px(h.charYPct-b.yPct));
    if (dist <= pct2px(BURST_R_PCT)){
      for (let i=0;i<LEAF_COUNT;i++) b.leafs.push(mkLeaf(b.xPct,b.yPct));
      const tNow = performance.now();
      b.berries.forEach(be=>{
        const a=rnd(0,Math.PI*2), d=rnd(SCATTER_MIN_PCT,SCATTER_MAX_PCT), v=vec(a);
        Object.assign(be,{
          x0:be.xPct, y0:be.yPct,
          tx:b.xPct+v.x*d, ty:b.yPct+v.y*d,
          flying:true, tFly0:tNow, flyDur:BERRY_FLY_MS,
          onBush:false, scale:1
        });
      });
      b.stage = 'exploded';
      busy.delete(`${b.gridX},${b.gridY}`);
    }
    return;
  }

  /* exploded */
  if (b.stage==='exploded'){
    b.leafs = b.leafs.filter(l=>{
      const dt=1/60;
      l.xPct += l.vxPct*dt;
      l.yPct += l.vyPct*dt;
      l.rot  += l.angVel;
      return performance.now()-l.t0 < LEAF_LIFE_MS;
    });
    b.berries.forEach(be=>{
      if (!be.flying) return;
      const k = outCub(clamp((now-be.tFly0)/be.flyDur,0,1));
      be.xPct = be.x0+(be.tx-be.x0)*k;
      be.yPct = be.y0+(be.ty-be.y0)*k;
      if (k >= 1) be.flying = false;
    });
    /*     FIX – удаляем куст только когда все ягоды ПОДОБРАНЫ */
    if (!b.leafs.length && b.berries.every(be=>!be.alive)) b.stage='dead';
  }
}

/* ──────────────────── Подбор ягод + логи ─────────────────── */
function collectLoop(){
  const now  = performance.now();
  const hero = getHero();
  const hxPct = hero.charXPct, hyPct = hero.charYPct;
  const hx = pct2px(hxPct),   hy = pct2px(hyPct);

  /* лог координат героя только при движении */
  if ( lastHeroXPct===null || lastHeroYPct===null ||
       Math.abs(hxPct-lastHeroXPct) > HERO_EPS ||
       Math.abs(hyPct-lastHeroYPct) > HERO_EPS ){
    console.log(`[berries] hero %(${hxPct.toFixed(2)}%,${hyPct.toFixed(2)}%)`);
    lastHeroXPct = hxPct; lastHeroYPct = hyPct;
  }

  /* собираем все доступные ягоды вокруг */
  const candidates = [];
  bushes.forEach(b=>b.berries.forEach(be=>{
    if (be.alive && !be.onBush && !be.flying){
      const dist = Math.hypot(pct2px(be.xPct)-hx, pct2px(be.yPct)-hy);
      if (dist <= pct2px(PICK_R_PCT)) candidates.push({be, dist});
    }
  }));
  if (!candidates.length) return;

  candidates.sort((a,b)=>a.dist-b.dist);
  const {be, dist} = candidates[0];

  if (now - lastPickupMs < PICK_COOLDOWN_MS) return;  // кулдаун

  be.alive = false;                                    // собрали ягоду
  lastPickupMs = now;

  const total = (+localStorage.getItem('berriesCollected') || 0) + 1;
  localStorage.setItem('berriesCollected', total);

  console.log(`[berries] PICKED at %(${be.xPct.toFixed(2)}%,${be.yPct.toFixed(2)}%) `
    +`dPx=${dist.toFixed(1)} total=${total}`);
}

/* ──────────────────── Рендер ─────────────────────────────── */
function drawBush(b){
  if (b.stage==='exploded' || b.stage==='dead') return;
  const s = b.stage==='growing' ? b.scale : 1;
  if (useBushImg && bushImg.complete){
    ctx.drawImage(bushImg,
      pct2px(b.xPct)-60*s, pct2px(b.yPct)-50*s, 120*s, 100*s);
  }else{
    const r = pct2px(BUSH_R_PCT)*s;
    ctx.save();
    ctx.fillStyle='#145c2b';
    ctx.beginPath(); ctx.arc(pct2px(b.xPct), pct2px(b.yPct), r, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle='#197c3a';
    ctx.beginPath(); ctx.arc(pct2px(b.xPct)-0.3*r, pct2px(b.yPct)-0.2*r, 0.8*r, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(pct2px(b.xPct)+0.35*r, pct2px(b.yPct)-0.1*r, 0.75*r,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }
}
function drawBerry(be){
  const s = be.onBush ? be.scale : 1;
  if (useBerryImg && berryImg.complete){
    ctx.drawImage(berryImg,
      pct2px(be.xPct)-12*s, pct2px(be.yPct)-12*s, 24*s, 24*s);
  }else{
    const r = pct2px(BERRY_R_PCT)*s;
    ctx.save();
    ctx.fillStyle='#e11';
    ctx.beginPath(); ctx.arc(pct2px(be.xPct), pct2px(be.yPct), r, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle='rgba(255,255,255,0.6)';
    ctx.beginPath(); ctx.arc(pct2px(be.xPct)-0.35*r, pct2px(be.yPct)-0.35*r, 0.25*r, 0,
      Math.PI*2); ctx.fill();
    ctx.restore();
  }
}
function drawLeaf(l){
  const alpha = clamp(1-(performance.now()-l.t0)/LEAF_LIFE_MS,0,1);
  if (useLeafImg && leafImg.complete){
    ctx.save(); ctx.globalAlpha = alpha;
    ctx.translate(pct2px(l.xPct), pct2px(l.yPct)); ctx.rotate(l.rot);
    ctx.drawImage(leafImg, -14, -9, 28, 18); ctx.restore();
  }else{
    const w=pct2px(2), h=pct2px(1);
    ctx.save(); ctx.globalAlpha=alpha;
    ctx.translate(pct2px(l.xPct), pct2px(l.yPct)); ctx.rotate(l.rot);
    ctx.fillStyle='#1d8f46';
    ctx.beginPath(); ctx.moveTo(-w/2,0); ctx.lineTo(0,-h/2); ctx.lineTo(w/2,0); ctx.lineTo(0,h/2);
    ctx.closePath(); ctx.fill(); ctx.restore();
  }
}

/* ──────────────────── Главный цикл ───────────────────────── */
function frame(){
  bushes.forEach(b=>b.stage!=='dead' && updateBush(b));
  for (let i=bushes.length-1;i>=0;i--) if (bushes[i].stage==='dead') bushes.splice(i,1);
  collectLoop();

  ctx.clearRect(0,0,cw,ch);
  bushes.forEach(b=>{
    drawBush(b);
    b.leafs.forEach(drawLeaf);
    b.berries.forEach(be=>be.alive && drawBerry(be));
  });

  requestAnimationFrame(frame);
}
frame();
</script>
</body>
</html>
