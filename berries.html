<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>Berries (final + visible on bush)</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:transparent}
  /* канвас лежит поверх острова, пропускает клики-тапы вниз */
  canvas{display:block;position:absolute;top:0;left:0;pointer-events:none;background:transparent}
</style>
</head>
<body>
<canvas id="berriesCanvas"></canvas>

<script>
/*────────────────── ассеты ──────────────────*/
const BUSH_ASSET_URL  = '';     // укажите путь с 'images/…' — будут спрайты
const BERRY_ASSET_URL = './img/berry/1.png';
const LEAF_ASSET_URL  = '';

const useBushImg  = BUSH_ASSET_URL .includes('images');
const useBerryImg = BERRY_ASSET_URL.includes('images');
const useLeafImg  = LEAF_ASSET_URL .includes('images');

const bushImg  = useBushImg  ? new Image() : null;
const berryImg = useBerryImg ? new Image() : null;
const leafImg  = useLeafImg  ? new Image() : null;
if (bushImg ) bushImg .src = BUSH_ASSET_URL ;
if (berryImg) berryImg.src = BERRY_ASSET_URL;
if (leafImg ) leafImg .src = LEAF_ASSET_URL ;

/*────────────────── игровой баланс ─────────*/
const SPAWN_MS           = 1000;     // 1 куст в секунду
const BURST_R_PCT        = 12;       // радиус «взрыва» куста
const PICK_R_PCT         = 8;        // радиус подбора ягоды
const PICK_COOLDOWN_MS   = 1;      // ≥ 0.25 с между пикапами

const BUSH_GROW_MS       = 1000;
const BERRIES_GROW_MS    = 100;
const BERRIES_MIN_MAX    = [6,9];

const SCATTER_MIN_PCT    = 3;
const SCATTER_MAX_PCT    = 7.5;
const BERRY_FLY_MS       = 600;

const LEAF_COUNT         = 28;
const LEAF_LIFE_MS       = 700;
const LEAF_SPD_MIN       = 6;
const LEAF_SPD_MAX       = 10;

const BERRY_R_PCT        = 1.2;
const BUSH_R_PCT         = 3.7;

const PICK_OUT_MS        = 150;      // отлет
const PICK_IN_MS         = 250;      // влет
const PICK_OUT_DIST_PCT  = 0.25;     // 25 % радиуса

/*────────────────── утилиты ────────────────*/
const rnd  =(a,b)=>a+Math.random()*(b-a);
const rndi =(a,b)=>Math.floor(rnd(a,b+1));
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const vec  = a=>({x:Math.cos(a),y:Math.sin(a)});
const outBack=t=>{const c1=1.70158,c3=c1+1;return 1+c3*(t-1)**3+c1*(t-1)**2;};
const outCub =t=>1-(1-t)**3;
const lerp=(a,b,t)=>a+(b-a)*t;

/*────────────────── карта и герой ──────────*/
const map = JSON.parse(localStorage.getItem('map') || '[]');
const GRID_W = map[0]?.length || 0;
function getHero(){
  return JSON.parse(localStorage.getItem('heroState')
    || '{"charXPct":50,"charYPct":50,"facing":1,"isMoving":false}');
}

/*────────────────── канвас ─────────────────*/
const cvs=document.getElementById('berriesCanvas'),ctx=cvs.getContext('2d');
let cw=0,ch=0;const pct2px=p=>p*cw/100;
function resize(){cw=cvs.width=innerWidth;ch=cvs.height=innerHeight;}
addEventListener('resize',resize);resize();

/*────────────────── геометрия острова ──────*/
const land=[];map.forEach((row,y)=>row.forEach((c,x)=>c&&land.push({x,y})));
const cellPct = 100/GRID_W;
const center  =(x,y)=>({xPct:(x+0.5)*cellPct, yPct:(y+0.5)*cellPct});

/* рамки острова и кламп внутри поля */
const islandBounds = (()=>{
  if(!land.length) return {minXPct:0, maxXPct:100, minYPct:0, maxYPct:100};
  let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
  land.forEach(({x,y})=>{ if(x<minX)minX=x; if(y<minY)minY=y; if(x>maxX)maxX=x; if(y>maxY)maxY=y; });
  return {
    minXPct: minX*cellPct,
    maxXPct: (maxX+1)*cellPct,
    minYPct: minY*cellPct,
    maxYPct: (maxY+1)*cellPct,
  };
})();
function clampToIsland(xPct,yPct,radPct=0){
  const b=islandBounds;
  return {
    xPct: Math.max(b.minXPct+radPct, Math.min(b.maxXPct-radPct, xPct)),
    yPct: Math.max(b.minYPct+radPct, Math.min(b.maxYPct-radPct, yPct)),
  };
}

/*────────────────── сущности ───────────────*/
const bushes=[], busy=new Set();

function mkBerry(onBush,xPct,yPct){
  return {
    onBush, xPct, yPct,
    scale:0.01,                 // маленькая точка сразу видна
    t0:performance.now(),       // ← ФИКС: время появления
    alive:true,

    // данные полёта после «взрыва» куста
    x0:xPct, y0:yPct, tx:xPct, ty:yPct,
    flying:false, tFly0:0, flyDur:BERRY_FLY_MS,

    // стадия анимации подбора
    stage:'idle', tPick0:0, ux:0, uy:0
  };
}
function mkLeaf(xPct,yPct){
  const a=rnd(0,Math.PI*2), v=vec(a), spd=rnd(LEAF_SPD_MIN,LEAF_SPD_MAX);
  return {
    xPct, yPct, vxPct:v.x*spd, vyPct:v.y*spd,
    rot:rnd(0,Math.PI*2), angVel:rnd(-10,10)*(Math.PI/180),
    t0:performance.now()
  };
}

/*────────────────── спавн кустов ───────────*/
setInterval(()=>{
  if(!land.length) return;
  for(let i=0;i<30;i++){
    const c=land[Math.random()*land.length|0], key=`${c.x},${c.y}`;
    if(busy.has(key)) continue;
    busy.add(key);
    bushes.push({
      gridX:c.x, gridY:c.y, ...center(c.x,c.y),
      stage:'growing', t0:performance.now(), scale:0,
      berries:[], leafs:[]
    });
    break;
  }
}, SPAWN_MS);

/*────────────────── логика кустов ──────────*/
function updBush(b){
  const now=performance.now();

  if(b.stage==='growing'){
    b.scale = outBack(clamp((now-b.t0)/BUSH_GROW_MS,0,1));
    if(b.scale>=1){
      b.stage='ripe';
      const n=rndi(...BERRIES_MIN_MAX);
      for(let i=0;i<n;i++){
        const a=rnd(0,Math.PI*2), r=rnd(0.3,0.8)*BUSH_R_PCT, v=vec(a);
        b.berries.push(mkBerry(true, b.xPct+v.x*r, b.yPct+v.y*r));
      }
    }
    return;
  }

  if(b.stage==='ripe'){
    b.berries.forEach(be=>{
      be.scale = clamp((now-be.t0)/BERRIES_GROW_MS,0,1);
    });

    const h=getHero();
    const dist=Math.hypot(pct2px(h.charXPct-b.xPct),pct2px(h.charYPct-b.yPct));
    if(dist<=pct2px(BURST_R_PCT)){
      for(let i=0;i<LEAF_COUNT;i++) b.leafs.push(mkLeaf(b.xPct,b.yPct));

      const tNow=now;
      b.berries.forEach(be=>{
        const a=rnd(0,Math.PI*2), d=rnd(SCATTER_MIN_PCT,SCATTER_MAX_PCT), v=vec(a);
        Object.assign(be,{
          /* clamp within island */
          ...( ()=>{ const to=clampToIsland(b.xPct+v.x*d, b.yPct+v.y*d, BERRY_R_PCT); return { x0:be.xPct, y0:be.yPct, tx:to.xPct, ty:to.yPct, }; } )(),

          flying:true, tFly0:tNow, flyDur:BERRY_FLY_MS,
          onBush:false, scale:1
        });
      });
      b.stage='exploded';
      busy.delete(`${b.gridX},${b.gridY}`);
    }
    return;
  }

  if(b.stage==='exploded'){
    b.leafs = b.leafs.filter(l=>{
      const dt=1/60;
      l.xPct += l.vxPct*dt;
      l.yPct += l.vyPct*dt;
      l.rot  += l.angVel;
      return now-l.t0 < LEAF_LIFE_MS;
    });

    b.berries.forEach(be=>{
      if(be.flying){
        const k=outCub(clamp((now-be.tFly0)/be.flyDur,0,1));
        be.xPct = be.x0 + (be.tx-be.x0)*k;
        be.yPct = be.y0 + (be.ty-be.y0)*k;
                { const _p=clampToIsland(be.xPct, be.yPct, BERRY_R_PCT); be.xPct=_p.xPct; be.yPct=_p.yPct; }
        if(k>=1) be.flying=false;
      }
    });

    if(!b.leafs.length && b.berries.every(be=>!be.alive)) b.stage='dead';
  }
}

/*────────────────── подбор ягод ────────────*/
let lastPickMs = 0;
function collectLoop(){
  const now=performance.now(), hero=getHero();
  const hxPct=hero.charXPct, hyPct=hero.charYPct;
  const hx=pct2px(hxPct),  hy=pct2px(hyPct);

  /* анимируем уже «подхваченные» ягоды */
  bushes.forEach(b=>b.berries.forEach(be=>{
    if(be.stage==='collectOut'){
      const u=clamp((now-be.tPick0)/PICK_OUT_MS,0,1);
      be.xPct = lerp(be.x0, be.x0 + be.ux*PICK_OUT_DIST_PCT*PICK_R_PCT, u);
      be.yPct = lerp(be.y0, be.y0 + be.uy*PICK_OUT_DIST_PCT*PICK_R_PCT, u);
      { const _p=clampToIsland(be.xPct, be.yPct, BERRY_R_PCT); be.xPct=_p.xPct; be.yPct=_p.yPct; }
      if(u>=1){
        be.stage='collectIn';
        be.tPick0=now;
        be.x0=be.xPct; be.y0=be.yPct;
      }
    }else if(be.stage==='collectIn'){
      const u=clamp((now-be.tPick0)/PICK_IN_MS,0,1);
      be.xPct = lerp(be.x0,hxPct,u);
      be.yPct = lerp(be.y0,hyPct,u);
      if(u>=1){
        be.alive=false; be.stage='done';
        const total=(+localStorage.getItem('berriesCollected')||0)+1;
        localStorage.setItem('berriesCollected',total);
        console.log(`[berries] PICKED berry total=${total}`);
      }
    }
  }));

  if(now-lastPickMs<PICK_COOLDOWN_MS) return;

  /* ищем ближайшую «лежачую» ягоду */
  const cand=[];
  bushes.forEach(b=>b.berries.forEach(be=>{
    if(be.stage==='idle' && be.alive && !be.flying && !be.onBush){
      const d=Math.hypot(pct2px(be.xPct)-hx, pct2px(be.yPct)-hy);
      if(d<=pct2px(PICK_R_PCT)) cand.push({be,d});
    }
  }));
  if(!cand.length) return;
  cand.sort((a,b)=>a.d-b.d);
  const {be}=cand[0];
  lastPickMs=now;

  /* запускаем анимацию отлёта → влёта */
  const ux=be.xPct-hxPct, uy=be.yPct-hyPct, len=Math.hypot(ux,uy)||1;
  be.ux=ux/len; be.uy=uy/len;
  be.stage='collectOut'; be.tPick0=now;
  be.x0=be.xPct; be.y0=be.yPct;
}

/*────────────────── рендер ─────────────────*/
function drawBush(b){
  if(b.stage==='exploded'||b.stage==='dead')return;
  const s=b.stage==='growing'?b.scale:1;
  if(useBushImg && bushImg.complete){
    ctx.drawImage(bushImg,pct2px(b.xPct)-60*s,pct2px(b.yPct)-50*s,120*s,100*s);
  }else{
    const r=pct2px(BUSH_R_PCT)*s;
    ctx.save();ctx.fillStyle='#145c2b';
    ctx.beginPath();ctx.arc(pct2px(b.xPct),pct2px(b.yPct),r,0,Math.PI*2);ctx.fill();
    ctx.fillStyle='#197c3a';
    ctx.beginPath();ctx.arc(pct2px(b.xPct)-0.3*r,pct2px(b.yPct)-0.2*r,0.8*r,0,Math.PI*2);ctx.fill();
    ctx.beginPath();ctx.arc(pct2px(b.xPct)+0.35*r,pct2px(b.yPct)-0.1*r,0.75*r,0,Math.PI*2);ctx.fill();
    ctx.restore();
  }
}
function drawBerry(be){
  if(!be.alive && be.stage!=='collectOut' && be.stage!=='collectIn') return;
  const s=be.onBush?be.scale:1;
  if(useBerryImg && berryImg.complete){
    ctx.drawImage(berryImg,pct2px(be.xPct)-12*s,pct2px(be.yPct)-12*s,24*s,24*s);
  }else{
    const r=pct2px(BERRY_R_PCT)*s;
    ctx.save();ctx.fillStyle='#e11';
    ctx.beginPath();ctx.arc(pct2px(be.xPct),pct2px(be.yPct),r,0,Math.PI*2);ctx.fill();
    ctx.fillStyle='rgba(255,255,255,0.6)';
    ctx.beginPath();ctx.arc(pct2px(be.xPct)-0.35*r,pct2px(be.yPct)-0.35*r,0.25*r,0,Math.PI*2);ctx.fill();
    ctx.restore();
  }
}
function drawLeaf(l){
  const alpha=clamp(1-(performance.now()-l.t0)/LEAF_LIFE_MS,0,1);
  if(useLeafImg && leafImg.complete){
    ctx.save();ctx.globalAlpha=alpha;
    ctx.translate(pct2px(l.xPct),pct2px(l.yPct));ctx.rotate(l.rot);
    ctx.drawImage(leafImg,-14,-9,28,18);ctx.restore();
  }else{
    const w=pct2px(2), h=pct2px(1);
    ctx.save();ctx.globalAlpha=alpha;
    ctx.translate(pct2px(l.xPct),pct2px(l.yPct));ctx.rotate(l.rot);
    ctx.fillStyle='#1d8f46';
    ctx.beginPath();ctx.moveTo(-w/2,0);ctx.lineTo(0,-h/2);ctx.lineTo(w/2,0);ctx.lineTo(0,h/2);
    ctx.closePath();ctx.fill();ctx.restore();
  }
}

/*────────────────── главный цикл ───────────*/
function frame(){
  bushes.forEach(b=>b.stage!=='dead' && updBush(b));
  for(let i=bushes.length-1;i>=0;i--) if(bushes[i].stage==='dead') bushes.splice(i,1);
  collectLoop();

  ctx.clearRect(0,0,cw,ch);
  bushes.forEach(b=>{
    drawBush(b);
    b.leafs.forEach(drawLeaf);
    b.berries.forEach(drawBerry);
  });
  requestAnimationFrame(frame);
}
frame();
</script>
</body>
</html>
