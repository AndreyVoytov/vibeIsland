<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>Berries (final + visible on bush)</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:transparent}
  canvas{display:block;position:absolute;top:0;left:0;pointer-events:none;background:transparent}
</style>
</head>
<body>
<canvas id="berriesCanvas"></canvas>

<!-- конфиг ягод -->
<script src="./berries-config.js"></script>
<script src="./buildings-config.js"></script>

<script>
/* =========================
   конфиг / выбор ягоды
========================= */
function pickWeightedBerryIndex(list, getW){
  let sum = 0;
  for(let i=0;i<list.length;i++) sum += Math.max(0, +getW(i) || 0);
  if(sum <= 0) return 0;
  let r = Math.random() * sum;
  for(let i=0;i<list.length;i++){
    r -= Math.max(0, +getW(i) || 0);
    if(r <= 0) return i;
  }
  return list.length - 1;
}

const BERRIES_LIST = (window.BerriesConfig && Array.isArray(window.BerriesConfig.berries)) ? window.BerriesConfig.berries : [];

const getResourceWeight = (window.BerriesConfig && typeof window.BerriesConfig.getResourceWeight === 'function')
  ? window.BerriesConfig.getResourceWeight
  : (/*index*/)=>1;

function getUserState(){
  let user = {};
  try {
    user = JSON.parse(localStorage.getItem('user') || '{}');
  } catch (err) {
    user = {};
  }
  if(typeof user.money !== 'number' || Number.isNaN(user.money)){
    user.money = 0;
  }
  if(!user.unlockedResources || typeof user.unlockedResources !== 'object'){
    user.unlockedResources = {};
  }
  if(!Object.values(user.unlockedResources).some(Boolean) && BERRIES_LIST[0]){
    user.unlockedResources[BERRIES_LIST[0].id] = true;
  }
  localStorage.setItem('user', JSON.stringify(user));
  return user;
}

function setUserState(user){
  localStorage.setItem('user', JSON.stringify(user));
}

function getUnlockedResourceIds(){
  const user = getUserState();
  return Object.keys(user.unlockedResources).filter((id)=>user.unlockedResources[id]);
}

function getResourceProfitById(id){
  const found = BERRIES_LIST.find((entry)=>entry.id === id);
  if(found && typeof found.profit === 'number') return found.profit;
  return 1;
}
  
/* =========================
   1) ассеты куст/листья (опционально)
========================= */
const DEFAULT_BUSH_ASSET_URL = '';
const LEAF_ASSET_URL  = '';

const useLeafImg = LEAF_ASSET_URL.includes('images');
const leafImg = useLeafImg ? new Image() : null;
let leafImgOk = false;

function wireImg(img, setOk){
  if(!img) return;
  img.onload = () => setOk(true);
  img.onerror = () => setOk(false);
}
wireImg(leafImg, v=>leafImgOk=v);
if (leafImg) leafImg.src = LEAF_ASSET_URL;

function canDrawImg(img){
  return !!img && img.complete && img.naturalWidth > 0 && img.naturalHeight > 0;
}

/* =========================
   2) кэш картинок ягод/кустов
========================= */
const berryImgCache = new Map(); // url -> {img, ok}
function getBerryImgRec(url){
  if(!url) return null; // строго по правилу
  let rec = berryImgCache.get(url);
  if(rec) return rec;
  const img = new Image();
  rec = { img, ok:false };
  img.onload = () => { rec.ok = true; };
  img.onerror = () => { rec.ok = false; };
  img.src = url;
  berryImgCache.set(url, rec);
  return rec;
}

const bushImgCache = new Map(); // url -> {img, ok}
function getBushImgRec(url){
  if(!url) return null;
  let rec = bushImgCache.get(url);
  if(rec) return rec;
  const img = new Image();
  rec = { img, ok:false };
  img.onload = () => { rec.ok = true; };
  img.onerror = () => { rec.ok = false; };
  img.src = url;
  bushImgCache.set(url, rec);
  return rec;
}

/* =========================
   3) выбор ягоды по весам
========================= */
function pickWeightedIndex(list, getW){
  let sum = 0;
  for(let i=0;i<list.length;i++) sum += Math.max(0, +getW(i) || 0);
  if(sum <= 0) return 0;
  let r = Math.random() * sum;
  for(let i=0;i<list.length;i++){
    r -= Math.max(0, +getW(i) || 0);
    if(r <= 0) return i;
  }
  return list.length - 1;
}
function pickBerryDef(){
  if(!BERRIES_LIST.length) return {
    id:'fallback', titleRu:'Ягода', assetUrl:'', widthPx:24, heightPx:24,
    primitive:{base:'#e11', highlight:'rgba(255,255,255,0.6)'}
  };
  const unlocked = new Set(getUnlockedResourceIds());
  const available = BERRIES_LIST.filter((def)=>unlocked.has(def.id));
  const pool = available.length ? available : BERRIES_LIST;
  const idx = pickWeightedIndex(pool, (i) => {
    const originalIndex = BERRIES_LIST.indexOf(pool[i]);
    return getResourceWeight(originalIndex >= 0 ? originalIndex : i);
  });
  return pool[idx] || pool[0];
}

/* =========================
   4) баланс/константы
========================= */
const SPAWN_MS = 1000, BURST_R_PCT = 12, PICK_R_PCT = 8, PICK_COOLDOWN_MS = 1;
const BUSH_GROW_MS = 1000, BERRIES_GROW_MS = 100, BERRIES_MIN_MAX = [6,9];
const SCATTER_MIN_PCT = 5, SCATTER_MAX_PCT = 13, BERRY_FLY_MS = 200;
const LEAF_COUNT = 28, LEAF_LIFE_MS = 700, LEAF_SPD_MIN = 6, LEAF_SPD_MAX = 10;
const BERRY_R_PCT = 1.2, BUSH_R_PCT = 3.7;
const BUSH_TOP_GROW_MULT = 1.2;
const PICK_OUT_MS = 200, PICK_IN_MS = 200, PICK_OUT_DIST_PCT = 1;
const PICK_TARGET_UP_CELLS = 2.2;

/* хитбокс ног героя */
const HERO_PIVOT = { left: 1.7, right: 1.7, up: 4, down: -0.5 };

/* утилиты */
const rnd=(a,b)=>a+Math.random()*(b-a), rndi=(a,b)=>Math.floor(rnd(a,b+1));
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v)), vec=a=>({x:Math.cos(a),y:Math.sin(a)});
const outBack=t=>{const c1=1.70158,c3=c1+1;return 1+c3*(t-1)**3+c1*(t-1)**2;};
const outCub=t=>1-(1-t)**3, lerp=(a,b,t)=>a+(b-a)*t;
function getCam(){ return JSON.parse(localStorage.getItem('camera') || '{"x":0,"y":0}'); }

/* карта / герой */
const map = JSON.parse(localStorage.getItem('map') || '[]');
const GRID_W = map[0]?.length || 0;
function getHero(){ return JSON.parse(localStorage.getItem('heroState') || '{"charXPct":50,"charYPct":50,"facing":1,"isMoving":false}'); }
const buildingsConfig = window.BuildingsConfig || { getBuildingLayout: () => [] };
const buildingLayout = buildingsConfig.getBuildingLayout(map);
const buildingCells = new Set(
  Array.isArray(buildingLayout)
    ? buildingLayout.map((spot) => `${spot.x},${spot.y}`)
    : []
);

/* канвас */
const cvs=document.getElementById('berriesCanvas'),ctx=cvs.getContext('2d');
let cw=0,ch=0; const pct2px=p=>p*cw/100;
function resize(){
  const dpr = window.devicePixelRatio || 1;
  const width = innerWidth;
  const height = innerHeight;
  cvs.style.width = `${width}px`;
  cvs.style.height = `${height}px`;
  cvs.width = Math.round(width * dpr);
  cvs.height = Math.round(height * dpr);
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  cw = width;
  ch = height;
}
addEventListener('resize',resize); resize();

/* геометрия острова */
const land=[]; map.forEach((row,y)=>row.forEach((c,x)=>c&&land.push({x,y})));
const TARGET_BUSHES_AT_CURRENT_MAP = 30;
const BUSH_DENSITY = land.length ? (TARGET_BUSHES_AT_CURRENT_MAP / land.length) : 0.05;
const MAX_UNPICKED_BUSHES = Math.max(1, Math.round(land.length * BUSH_DENSITY));
const cellPct = GRID_W ? (100/GRID_W) : 0;
const center=(x,y)=>({xPct:(x+0.5)*cellPct, yPct:(y+0.5)*cellPct});
function getHeroRect(hxPct,hyPct){ return { left: hxPct-HERO_PIVOT.left*cellPct, right: hxPct+HERO_PIVOT.right*cellPct, top: hyPct-HERO_PIVOT.up*cellPct, bottom: hyPct+HERO_PIVOT.down*cellPct }; }
function isInHeroRect(xPct,yPct,hxPct,hyPct){ const r=getHeroRect(hxPct,hyPct); return (xPct>=r.left && xPct<=r.right && yPct>=r.top && yPct<=r.bottom); }
function bushTouchesHero(bxPct,byPct,hxPct,hyPct,radPct=BUSH_R_PCT){
  const r=getHeroRect(hxPct,hyPct);
  const cx=Math.max(r.left,Math.min(r.right,bxPct));
  const cy=Math.max(r.top,Math.min(r.bottom,byPct));
  const dx=pct2px(bxPct-cx), dy=pct2px(byPct-cy);
  return Math.hypot(dx,dy)<=pct2px(radPct);
}
const islandBounds=(()=>{ if(!land.length) return {minXPct:0,maxXPct:100,minYPct:0,maxYPct:100};
  let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
  land.forEach(({x,y})=>{if(x<minX)minX=x;if(y<minY)minY=y;if(x>maxX)maxX=x;if(y>maxY)maxY=y;});
  return {minXPct:minX*cellPct,maxXPct:(maxX+1)*cellPct,minYPct:minY*cellPct,maxYPct:(maxY+1)*cellPct};
})();
function clampToIsland(xPct,yPct,radPct=0){ const b=islandBounds;
  return {
    xPct:Math.max(b.minXPct+radPct,Math.min(b.maxXPct-radPct,xPct)),
    yPct:Math.max(b.minYPct+radPct,Math.min(b.maxYPct-radPct,yPct))
  };
}

/* =========================
   5) сущности
========================= */
const bushes=[], busy=new Set();

function mkBerry(onBush,xPct,yPct,def){
  return {
    def,
    onBush, xPct, yPct,
    scale:0.01, t0:performance.now(), alive:true,
    x0:xPct,y0:yPct,tx:xPct,ty:yPct,
    flying:false,tFly0:0,flyDur:BERRY_FLY_MS,
    stage:'idle',tPick0:0,ux:0,uy:0
  };
}
function mkLeaf(xPct,yPct){
  const a=rnd(0,Math.PI*2), v=vec(a), spd=rnd(LEAF_SPD_MIN,LEAF_SPD_MAX);
  return { xPct,yPct, vxPct:v.x*spd, vyPct:v.y*spd, rot:rnd(0,Math.PI*2), angVel:rnd(-10,10)*(Math.PI/180), t0:performance.now() };
}

function getBushVisualDef(bush){
  const def = bush.berryDef || {};
  return {
    type: def.bushType || 'default',
    scale: typeof def.bushScale === 'number' ? def.bushScale : 1,
    assetUrl: def.bushAssetUrl || DEFAULT_BUSH_ASSET_URL,
    primitive: def.bushPrimitive || null,
  };
}

/* =========================
   6) спавн кустов
========================= */
setInterval(()=>{ if(!land.length) return;
  const unpicked=bushes.filter(b=>b.stage==='growing'||b.stage==='ripe').length;
  if(unpicked>=MAX_UNPICKED_BUSHES) return;

  for(let i=0;i<30;i++){
    const c=land[Math.random()*land.length|0], key=`${c.x},${c.y}`;
    if(buildingCells.has(key)) continue;
    if(busy.has(key)) continue;
    busy.add(key);
    bushes.push({
      gridX:c.x, gridY:c.y, ...center(c.x,c.y),
      stage:'growing', t0:performance.now(), scale:0,
      berries:[], leafs:[], berryDef:null
    });
    break;
  }
}, SPAWN_MS);

/* =========================
   7) логика
========================= */
function updBush(b){
  const now=performance.now();

  if(b.stage==='growing'){
    b.scale = outBack(clamp((now-b.t0)/BUSH_GROW_MS,0,1));
    if(b.scale>=1){
      b.stage='ripe';
      const n=rndi(...BERRIES_MIN_MAX);

	  //Спавн с разными ягодами на кусте, оставим на потом
      //for(let i=0;i<n;i++){
      //  const a=rnd(0,Math.PI*2), r=rnd(0.3,0.8)*BUSH_R_PCT, v=vec(a);
      //  const def = pickBerryDef(); // ВАЖНО: выбор для каждой ягоды
      //  b.berries.push(mkBerry(true, b.xPct+v.x*r, b.yPct+v.y*r, def));
      //}
	  
      if(!b.berryDef) b.berryDef = pickBerryDef(); // <-- один раз на куст
      const bushType = b.berryDef && b.berryDef.bushType;

      for(let i=0;i<n;i++){
        if(bushType === 'centered'){
          b.berries.push(mkBerry(true, b.xPct, b.yPct, b.berryDef));
          continue;
        }
        const a=rnd(0,Math.PI*2), r=rnd(0.3,0.8)*BUSH_R_PCT, v=vec(a);
        b.berries.push(mkBerry(true, b.xPct+v.x*r, b.yPct+v.y*r, b.berryDef));
      }
    }
    return;
  }

  if(b.stage==='ripe'){
    b.berries.forEach(be=>{ be.scale = clamp((now-be.t0)/BERRIES_GROW_MS,0,1); });

    const h=getHero();
    const dist=Math.hypot(pct2px(h.charXPct-b.xPct),pct2px(h.charYPct-b.yPct));
    const touch = bushTouchesHero(b.xPct,b.yPct,h.charXPct,h.charYPct,BUSH_R_PCT);

    if (touch || dist <= pct2px(BURST_R_PCT)) {
      for(let i=0;i<LEAF_COUNT;i++) b.leafs.push(mkLeaf(b.xPct,b.yPct));

      const tNow=now;
      b.berries.forEach(be=>{
        const a=rnd(0,Math.PI*2), d=rnd(SCATTER_MIN_PCT,SCATTER_MAX_PCT), v=vec(a);
        const to = clampToIsland(b.xPct+v.x*d, b.yPct+v.y*d, BERRY_R_PCT);
        Object.assign(be,{
          x0:be.xPct,y0:be.yPct, tx:to.xPct,ty:to.yPct,
          flying:true,tFly0:tNow,flyDur:BERRY_FLY_MS,
          onBush:false,scale:1
        });
      });

      b.stage='exploded';
      busy.delete(`${b.gridX},${b.gridY}`);

      // триггерим удар — heroAnimation сам проиграет, если не занят
      localStorage.setItem('heroAction', JSON.stringify({chopAt: now}));
    }
    return;
  }

  if(b.stage==='exploded'){
    b.leafs = b.leafs.filter(l=>{
      const dt=1/60;
      l.xPct += l.vxPct*dt; l.yPct += l.vyPct*dt; l.rot += l.angVel;
      return now-l.t0 < LEAF_LIFE_MS;
    });

    b.berries.forEach(be=>{
      if(be.flying){
        const k=outCub(clamp((now-be.tFly0)/be.flyDur,0,1));
        be.xPct=be.x0+(be.tx-be.x0)*k;
        be.yPct=be.y0+(be.ty-be.y0)*k;
        if(k>=1) be.flying=false;
      }
    });

    if(!b.leafs.length && b.berries.every(be=>!be.alive)) b.stage='dead';
  }
}

/* =========================
   8) подбор ягод
========================= */
let lastPickMs = 0;
function collectLoop(){
  const now=performance.now(), hero=getHero();
  const hxPct=hero.charXPct, hyPct=hero.charYPct;
  const hx=pct2px(hxPct),  hy=pct2px(hyPct);
  const pickTargetYPct = hyPct - PICK_TARGET_UP_CELLS * cellPct;

  bushes.forEach(b=>b.berries.forEach(be=>{
    if(be.stage==='collectOut'){
      const u=clamp((now-be.tPick0)/PICK_OUT_MS,0,1);
      be.xPct = lerp(be.x0, be.x0 + be.ux*PICK_OUT_DIST_PCT*PICK_R_PCT, u);
      be.yPct = lerp(be.y0, be.y0 + be.uy*PICK_OUT_DIST_PCT*PICK_R_PCT, u);
      if(u>=1){ be.stage='collectIn'; be.tPick0=now; be.x0=be.xPct; be.y0=be.yPct; }
    }else if(be.stage==='collectIn'){
      const u=clamp((now-be.tPick0)/PICK_IN_MS,0,1);
      be.xPct = lerp(be.x0,hxPct,u); be.yPct = lerp(be.y0,pickTargetYPct,u);
      if(u>=1){
        be.alive=false; be.stage='done';
        const total=(+localStorage.getItem('berriesCollected')||0)+1;
        localStorage.setItem('berriesCollected',total);
        const profit = getResourceProfitById(be.def && be.def.id);
        const user = getUserState();
        user.money = (user.money || 0) + profit;
        setUserState(user);
      }
    }
  }));

  if(now-lastPickMs<PICK_COOLDOWN_MS) return;

  const cand = [];
  bushes.forEach(b=>b.berries.forEach(be=>{
    if(be.stage==='idle'&&be.alive&&!be.flying&&!be.onBush){
      const d=Math.hypot(pct2px(be.xPct)-hx,pct2px(be.yPct)-hy);
      const under = isInHeroRect(be.xPct,be.yPct,hxPct,hyPct);
      if(under || d<=pct2px(PICK_R_PCT)) cand.push({be,d});
    }
  }));
  if(!cand.length) return;

  cand.sort((a,b)=>a.d-b.d);
  const { be } = cand[0];
  lastPickMs = now;

  const ux=be.xPct-hxPct, uy=be.yPct-hyPct, len=Math.hypot(ux,uy)||1;
  be.ux=ux/len; be.uy=uy/len;

  be.stage='collectOut'; be.tPick0=now; be.x0=be.xPct; be.y0=be.yPct;
}

/* =========================
   9) рендер
========================= */
function getBushScale(stage, t0, now){
  if(stage !== 'growing') return 1;
  return outBack(clamp((now - t0) / BUSH_GROW_MS, 0, 1));
}

function getTopBushScale(stage, t0, now){
  if(stage !== 'growing') return 1;
  const grow = clamp(((now - t0) * BUSH_TOP_GROW_MULT) / BUSH_GROW_MS, 0, 1);
  return outBack(grow);
}

function getCenteredBushScale(now, b){
  const grow = clamp((now - b.t0) / BUSH_GROW_MS, 0, 1);
  return {
    sx: lerp(0.6, 1, outCub(grow)),
    sy: lerp(0.2, 1, outBack(grow)),
  };
}

function drawMushroomPrimitive(x, y, w, h, primitive){
  const cap = primitive.cap || '#f2e9dd';
  const capShade = primitive.capShade || '#d6c7b4';
  const stem = primitive.stem || '#e6d7c3';
  const grass = primitive.grass || '#1f8b45';
  const spots = primitive.spots || '#ffffff';
  const shadow = primitive.shadow || 'rgba(0,0,0,0.2)';

  ctx.save();
  ctx.fillStyle = shadow;
  ctx.beginPath();
  ctx.ellipse(x, y + h * 0.25, w * 0.4, h * 0.1, 0, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = grass;
  ctx.beginPath();
  ctx.ellipse(x, y + h * 0.32, w * 0.45, h * 0.13, 0, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = stem;
  ctx.beginPath();
  ctx.moveTo(x - w * 0.12, y - h * 0.05);
  ctx.lineTo(x + w * 0.12, y - h * 0.05);
  ctx.lineTo(x + w * 0.12, y + h * 0.23);
  ctx.lineTo(x - w * 0.12, y + h * 0.23);
  ctx.closePath();
  ctx.fill();

  ctx.fillStyle = cap;
  ctx.beginPath();
  ctx.ellipse(x, y - h * 0.1, w * 0.45, h * 0.32, 0, Math.PI, 0);
  ctx.fill();
  ctx.fillStyle = capShade;
  ctx.beginPath();
  ctx.ellipse(x, y - h * 0.02, w * 0.4, h * 0.24, 0, Math.PI, 0);
  ctx.fill();

  ctx.fillStyle = spots;
  ctx.beginPath(); ctx.arc(x - w * 0.2, y - h * 0.17, w * 0.04, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(x + w * 0.05, y - h * 0.2, w * 0.05, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(x + w * 0.22, y - h * 0.14, w * 0.035, 0, Math.PI * 2); ctx.fill();
  ctx.restore();
}

function drawBeetPrimitive(x, y, w, h, primitive){
  const root = primitive.root || '#8a1227';
  const leaf = primitive.leaf || '#2f9b52';
  const grass = primitive.grass || '#1b7d3e';
  const shadow = primitive.shadow || 'rgba(0,0,0,0.2)';

  ctx.save();
  ctx.fillStyle = shadow;
  ctx.beginPath();
  ctx.ellipse(x, y + h * 0.25, w * 0.4, h * 0.1, 0, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = grass;
  ctx.beginPath();
  ctx.ellipse(x, y + h * 0.28, w * 0.45, h * 0.12, 0, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = root;
  ctx.beginPath();
  ctx.ellipse(x, y + h * 0.05, w * 0.28, h * 0.32, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(x, y + h * 0.35);
  ctx.lineTo(x - w * 0.08, y + h * 0.45);
  ctx.lineTo(x + w * 0.08, y + h * 0.45);
  ctx.closePath();
  ctx.fill();

  ctx.fillStyle = leaf;
  ctx.beginPath();
  ctx.moveTo(x, y - h * 0.1);
  ctx.quadraticCurveTo(x - w * 0.35, y - h * 0.35, x - w * 0.1, y - h * 0.45);
  ctx.quadraticCurveTo(x - w * 0.15, y - h * 0.25, x, y - h * 0.1);
  ctx.fill();

  ctx.beginPath();
  ctx.moveTo(x, y - h * 0.12);
  ctx.quadraticCurveTo(x + w * 0.35, y - h * 0.35, x + w * 0.1, y - h * 0.45);
  ctx.quadraticCurveTo(x + w * 0.15, y - h * 0.2, x, y - h * 0.12);
  ctx.fill();
  ctx.restore();
}

function drawBushCentered(b, now, visual){
  if(b.stage==='exploded'||b.stage==='dead') return;
  const { sx, sy } = getCenteredBushScale(now, b);
  const base = pct2px(BUSH_R_PCT);
  const scale = typeof visual.scale === 'number' ? visual.scale : 1;
  const w = base * 6 * sx * scale;
  const h = base * 5 * sy * scale;
  const x = pct2px(b.xPct);
  const y = pct2px(b.yPct);
  const rec = getBushImgRec(visual.assetUrl);

  if(rec && rec.ok && canDrawImg(rec.img)){
    ctx.drawImage(rec.img, x - w / 2, y - h * 0.45, w, h);
    return;
  }

  const primitive = visual.primitive || {};
  if(primitive.kind === 'beet'){
    drawBeetPrimitive(x, y, w, h, primitive);
    return;
  }
  drawMushroomPrimitive(x, y, w, h, primitive);
}

function drawBushBottom(b, now, visual){
  if(b.stage==='exploded'||b.stage==='dead') return;
  const s = getBushScale(b.stage, b.t0, now);
  const rec = getBushImgRec(visual.assetUrl);

  if(rec && rec.ok && canDrawImg(rec.img)){
    ctx.drawImage(rec.img, pct2px(b.xPct)-60*s, pct2px(b.yPct)-50*s, 120*s, 100*s);
  }else{
    const r=pct2px(BUSH_R_PCT)*s;
    ctx.save();
    ctx.fillStyle='#145c2b';
    ctx.beginPath(); ctx.arc(pct2px(b.xPct),pct2px(b.yPct),r,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#197c3a';
    ctx.beginPath(); ctx.arc(pct2px(b.xPct)-0.3*r,pct2px(b.yPct)-0.2*r,0.8*r,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(pct2px(b.xPct)+0.35*r,pct2px(b.yPct)-0.1*r,0.75*r,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }
}

function drawBushTop(b, now){
  if(b.stage==='exploded'||b.stage==='dead') return;
  const visual = getBushVisualDef(b);
  const rec = getBushImgRec(visual.assetUrl);
  if(rec && rec.ok && canDrawImg(rec.img)) return;

  const s = getTopBushScale(b.stage, b.t0, now);
  const r = pct2px(BUSH_R_PCT) * s;
  ctx.save();
  ctx.fillStyle='#1a7b38';
  ctx.beginPath(); ctx.arc(pct2px(b.xPct)-0.2*r,pct2px(b.yPct)-0.35*r,0.82*r,0,Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(pct2px(b.xPct)+0.35*r,pct2px(b.yPct)-0.3*r,0.9*r,0,Math.PI*2); ctx.fill();
  ctx.restore();
}

function drawBerry(be){
  if(!be.alive && be.stage!=='collectOut' && be.stage!=='collectIn') return;
  if(be.onBush && be.def && be.def.bushType === 'centered') return;
  const s = be.onBush ? be.scale : 1;
  const def = be.def || { widthPx:24,heightPx:24,assetUrl:'',primitive:{base:'#e11',highlight:'rgba(255,255,255,0.6)'} };

  const rec = getBerryImgRec(def.assetUrl);
  if(rec && rec.ok && canDrawImg(rec.img)){
    const w = (def.widthPx || 24) * s;
    const h = (def.heightPx || 24) * s;
    ctx.drawImage(rec.img, pct2px(be.xPct)-w/2, pct2px(be.yPct)-h/2, w, h);
    return;
  }

  const r = pct2px(BERRY_R_PCT) * s;
  const primitive = def.primitive || {};
  if(primitive.kind === 'mushroom'){
    ctx.save();
    ctx.fillStyle = primitive.stem || '#e1d2bf';
    ctx.fillRect(pct2px(be.xPct)-r*0.2, pct2px(be.yPct)+r*0.05, r*0.4, r*0.5);
    ctx.fillStyle = primitive.cap || '#f4eee6';
    ctx.beginPath();
    ctx.ellipse(pct2px(be.xPct), pct2px(be.yPct)-r*0.1, r*0.7, r*0.5, 0, Math.PI, 0);
    ctx.fill();
    ctx.fillStyle = primitive.spots || 'rgba(255,255,255,0.85)';
    ctx.beginPath(); ctx.arc(pct2px(be.xPct)-r*0.2, pct2px(be.yPct)-r*0.2, r*0.12, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(pct2px(be.xPct)+r*0.15, pct2px(be.yPct)-r*0.18, r*0.1, 0, Math.PI * 2); ctx.fill();
    ctx.restore();
    return;
  }
  if(primitive.kind === 'beet'){
    ctx.save();
    ctx.fillStyle = primitive.root || '#9b1b30';
    ctx.beginPath();
    ctx.ellipse(pct2px(be.xPct), pct2px(be.yPct)+r*0.1, r*0.6, r*0.7, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = primitive.leaf || '#2f9b52';
    ctx.beginPath();
    ctx.moveTo(pct2px(be.xPct), pct2px(be.yPct)-r*0.1);
    ctx.lineTo(pct2px(be.xPct)-r*0.45, pct2px(be.yPct)-r*0.6);
    ctx.lineTo(pct2px(be.xPct)-r*0.1, pct2px(be.yPct)-r*0.55);
    ctx.closePath();
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(pct2px(be.xPct), pct2px(be.yPct)-r*0.1);
    ctx.lineTo(pct2px(be.xPct)+r*0.45, pct2px(be.yPct)-r*0.6);
    ctx.lineTo(pct2px(be.xPct)+r*0.1, pct2px(be.yPct)-r*0.55);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
    return;
  }
  ctx.save();
  ctx.fillStyle = (def.primitive && def.primitive.base) ? def.primitive.base : '#e11';
  ctx.beginPath(); ctx.arc(pct2px(be.xPct),pct2px(be.yPct),r,0,Math.PI*2); ctx.fill();
  ctx.fillStyle = (def.primitive && def.primitive.highlight) ? def.primitive.highlight : 'rgba(255,255,255,0.6)';
  ctx.beginPath(); ctx.arc(pct2px(be.xPct)-0.35*r,pct2px(be.yPct)-0.35*r,0.25*r,0,Math.PI*2); ctx.fill();
  ctx.restore();
}

function drawLeaf(l){
  const alpha=clamp(1-(performance.now()-l.t0)/LEAF_LIFE_MS,0,1);

  if(useLeafImg && leafImgOk && canDrawImg(leafImg)){
    ctx.save();
    ctx.globalAlpha=alpha;
    ctx.translate(pct2px(l.xPct),pct2px(l.yPct));
    ctx.rotate(l.rot);
    ctx.drawImage(leafImg,-14,-9,28,18);
    ctx.restore();
  }else{
    const w=pct2px(2), h=pct2px(1);
    ctx.save();
    ctx.globalAlpha=alpha;
    ctx.translate(pct2px(l.xPct),pct2px(l.yPct));
    ctx.rotate(l.rot);
    ctx.fillStyle='#1d8f46';
    ctx.beginPath();
    ctx.moveTo(-w/2,0); ctx.lineTo(0,-h/2); ctx.lineTo(w/2,0); ctx.lineTo(0,h/2);
    ctx.closePath(); ctx.fill();
    ctx.restore();
  }
}

/* =========================
   10) главный цикл
========================= */
function frame(){
  bushes.forEach(b=>b.stage!=='dead' && updBush(b));
  for(let i=bushes.length-1;i>=0;i--) if(bushes[i].stage==='dead') bushes.splice(i,1);

  collectLoop();

  const cam = getCam();
  const now = performance.now();
  ctx.clearRect(0,0,cw,ch);
  ctx.save();
  ctx.translate(-cam.x, -cam.y);
  bushes.forEach(b=>{
    const visual = getBushVisualDef(b);
    if(visual.type === 'centered'){
      drawBushCentered(b, now, visual);
    }else{
      drawBushBottom(b, now, visual);
    }
    b.leafs.forEach(drawLeaf);
    b.berries.forEach(drawBerry);
    if(visual.type !== 'centered'){
      drawBushTop(b, now);
    }
  });
  ctx.restore();

  requestAnimationFrame(frame);
}
frame();
</script>
</body>
</html>
