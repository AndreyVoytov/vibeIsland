<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Buildings Layer</title>
  <style>
    html,body{margin:0;height:100%;overflow:hidden;background:transparent}
    canvas{display:block;position:absolute;top:0;left:0;pointer-events:none;background:transparent}
  </style>
</head>
<body>
  <canvas id="buildingsCanvas"></canvas>

  <script src="./buildings-config.js"></script>
  <script>
    let map = [];
    let GRID_H = 0;
    let GRID_W = 0;

    const buildingsConfig = window.BuildingsConfig || { buildings: [], getBuildingLayout: () => [] };
    const buildingDefs = buildingsConfig.buildings || [];
    const buildingById = new Map(buildingDefs.map((item) => [item.id, item]));

    const campfireUpgradeIds = ['campfire-upgrade-3', 'campfire-upgrade-2', 'campfire-upgrade-1'];
    let layout = [];

    function getBuildingCellPx(worldCellPx){
      const value = buildingsConfig.buildingCellPx;
      if(Number.isFinite(value)) return value;
      return Number.isFinite(worldCellPx) ? worldCellPx : 0;
    }

    function getVirtualCellPx(worldCellPx){
      const value = buildingsConfig.virtualCellPx;
      if(Number.isFinite(value)) return value;
      return Number.isFinite(worldCellPx) ? worldCellPx : 0;
    }

    const WORLD_ZOOM = 1.15;

    function getExpansionLevel(){
      const stored = Number(localStorage.getItem('islandExpansionLevel') || '0');
      if(!Number.isFinite(stored)) return 0;
      return Math.max(0, Math.floor(stored));
    }

    function getBaseGridW(){
      const stored = Number(localStorage.getItem('baseGridW') || '0');
      if(Number.isFinite(stored) && stored > 0) return stored;
      if(GRID_W){
        localStorage.setItem('baseGridW', String(GRID_W));
        return GRID_W;
      }
      return 0;
    }

    function getWorldCellPx(){
      const gameW = parseFloat(localStorage.getItem('gameWidth')) || innerWidth;
      const baseGridW = getBaseGridW();
      if(!baseGridW) return 0;
      const scale = Math.pow(0.97, getExpansionLevel()) * WORLD_ZOOM;
      return (gameW / baseGridW) * scale;
    }

    const canvas = document.getElementById('buildingsCanvas');
    const ctx = canvas.getContext('2d');

    let cw = 0;
    let ch = 0;

    function loadMap(){
      try {
        const stored = JSON.parse(localStorage.getItem('map') || '[]');
        map = Array.isArray(stored) ? stored : [];
      } catch (err) {
        map = [];
      }
      GRID_H = map.length;
      GRID_W = map[0] ? map[0].length : 0;

      // layout: позиции зданий в КЛЕТКАХ (x,y)
      layout = buildingsConfig.getBuildingLayout(map);
    }
    loadMap();

    function resize(){
      const dpr = window.devicePixelRatio || 1;
      const width = innerWidth;
      const height = innerHeight;

      canvas.style.width = `${width}px`;
      canvas.style.height = `${height}px`;
      canvas.width = Math.round(width * dpr);
      canvas.height = Math.round(height * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      cw = width;
      ch = height;
    }

    const imageCache = new Map();
    function getImageRecord(url){
      if(!url) return null;
      let record = imageCache.get(url);
      if(record) return record;

      const img = new Image();
      record = { img, ok: false };
      img.onload = () => { record.ok = true; };
      img.onerror = () => { record.ok = false; };
      img.src = url;

      imageCache.set(url, record);
      return record;
    }

    function getUserState(){
      let user = {};
      try { user = JSON.parse(localStorage.getItem('user') || '{}'); }
      catch (err) { user = {}; }

      if(!user.unlockedResources || typeof user.unlockedResources !== 'object'){
        user.unlockedResources = {};
      }
      return user;
    }

    function drawRoundedRect(x, y, w, h, r){
      if(ctx.roundRect){
        ctx.beginPath();
        ctx.roundRect(x, y, w, h, r);
        ctx.fill();
        return;
      }
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.lineTo(x + w - r, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + r);
      ctx.lineTo(x + w, y + h - r);
      ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
      ctx.lineTo(x + r, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - r);
      ctx.lineTo(x, y + r);
      ctx.quadraticCurveTo(x, y, x + r, y);
      ctx.fill();
    }

    function drawPrimitive(def, centerX, centerY, size){
      const primitive = def.primitive || {};
      const half = size / 2;
      const baseX = centerX - half;
      const baseY = centerY - half;
      const radius = size * 0.18;

      ctx.save();

      if(primitive.kind === 'campfire'){
        ctx.globalAlpha = 0.5;
        ctx.fillStyle = primitive.glow || 'rgba(255,160,80,0.5)';
        ctx.beginPath();
        ctx.ellipse(centerX, centerY + size * 0.1, size * 0.5, size * 0.3, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.globalAlpha = 1;
        ctx.fillStyle = primitive.stone || '#6e7a86';
        drawRoundedRect(baseX + size * 0.15, baseY + size * 0.55, size * 0.7, size * 0.25, radius);

        ctx.fillStyle = primitive.base || '#5b4636';
        drawRoundedRect(baseX + size * 0.2, baseY + size * 0.65, size * 0.6, size * 0.18, radius * 0.6);

        ctx.fillStyle = primitive.flame || '#ff8a3d';
        ctx.beginPath();
        ctx.moveTo(centerX, baseY + size * 0.2);
        ctx.quadraticCurveTo(baseX + size * 0.75, baseY + size * 0.45, centerX, baseY + size * 0.7);
        ctx.quadraticCurveTo(baseX + size * 0.25, baseY + size * 0.45, centerX, baseY + size * 0.2);
        ctx.fill();

        ctx.restore();
        return;
      }

      if(primitive.kind === 'whetstone'){
        ctx.fillStyle = primitive.base || '#9da3aa';
        drawRoundedRect(baseX + size * 0.12, baseY + size * 0.2, size * 0.76, size * 0.6, radius);
        ctx.fillStyle = primitive.edge || '#dfe5ec';
        drawRoundedRect(baseX + size * 0.22, baseY + size * 0.32, size * 0.56, size * 0.3, radius * 0.6);
        ctx.fillStyle = primitive.accent || '#6e747c';
        ctx.fillRect(baseX + size * 0.2, baseY + size * 0.65, size * 0.6, size * 0.06);
        ctx.restore();
        return;
      }

      if(primitive.kind === 'forge'){
        ctx.fillStyle = primitive.base || '#5b3b2d';
        drawRoundedRect(baseX + size * 0.1, baseY + size * 0.25, size * 0.8, size * 0.65, radius);
        ctx.fillStyle = primitive.roof || '#343a40';
        drawRoundedRect(baseX + size * 0.2, baseY + size * 0.15, size * 0.6, size * 0.18, radius * 0.7);
        ctx.fillStyle = primitive.metal || '#c0c7cf';
        drawRoundedRect(baseX + size * 0.28, baseY + size * 0.45, size * 0.44, size * 0.28, radius * 0.6);
        ctx.fillStyle = primitive.fire || '#ff7a35';
        ctx.beginPath();
        ctx.moveTo(centerX, baseY + size * 0.48);
        ctx.quadraticCurveTo(baseX + size * 0.62, baseY + size * 0.58, centerX, baseY + size * 0.7);
        ctx.quadraticCurveTo(baseX + size * 0.38, baseY + size * 0.58, centerX, baseY + size * 0.48);
        ctx.fill();
        ctx.restore();
        return;
      }

      ctx.fillStyle = primitive.base || '#2f3a4a';
      drawRoundedRect(baseX + size * 0.1, baseY + size * 0.2, size * 0.8, size * 0.65, radius);
      ctx.fillStyle = primitive.accent || '#59687a';
      drawRoundedRect(baseX + size * 0.22, baseY + size * 0.35, size * 0.56, size * 0.2, radius * 0.6);
      ctx.fillStyle = primitive.marker || '#ff6b6b';
      drawRoundedRect(baseX + size * 0.2, baseY + size * 0.12, size * 0.6, size * 0.12, radius * 0.4);
      ctx.restore();
    }

    /**
     * КЛЮЧЕВОЕ:
     * - ЯКОРЬ = костёр (в координатах карты, не камеры)
     * - Все здания смещаем относительно костра в VIRTUAL_CELL_PX
     * - Размеры зданий фиксированные
     */
    function drawBuilding(def, position, cell, anchorSpot, buildingCellPx, virtualCellPx){
      const radius = Number.isFinite(def?.colliderRadius) ? Math.max(1, def.colliderRadius) : 2;

      // фиксированный размер
      const size = buildingCellPx * 0.82 * (radius * 2 + 1);

      // якорь в пикселях мира = позиция костра на карте (через cell)
      const anchorX = (anchorSpot.x + 0.5) * cell;
      const anchorY = (anchorSpot.y + 0.5) * cell;

      // смещения относительно костра (виртуальные пиксели)
      const dx = (position.x - anchorSpot.x) * virtualCellPx;
      const dy = (position.y - anchorSpot.y) * virtualCellPx;

      const centerX = anchorX + dx;
      const centerY = anchorY + dy;

      const imgRec = def?.assetUrl ? getImageRecord(def.assetUrl) : null;
      if(imgRec && imgRec.ok && imgRec.img.complete && imgRec.img.naturalWidth > 0){
        ctx.drawImage(imgRec.img, centerX - size / 2, centerY - size / 2, size, size);
        return;
      }
      drawPrimitive(def, centerX, centerY, size);
    }

    function getWiggleOffset(cell){
      const start = Number(localStorage.getItem('islandWiggleAt') || 0);
      if(!start) return { x: 0, y: 0 };

      const duration = 5000;
      const elapsed = performance.now() - start;
      if(elapsed < 0 || elapsed > duration) return { x: 0, y: 0 };

      const t = elapsed / duration;
      const decay = 1 - t;

      return {
        x: Math.sin(t * Math.PI * 4) * cell * 0.12 * decay,
        y: Math.cos(t * Math.PI * 4) * cell * 0.08 * decay,
      };
    }

    function render(){
      ctx.clearRect(0, 0, cw, ch);

      const cell = getWorldCellPx();
      const cam = JSON.parse(localStorage.getItem('camera') || '{"x":0,"y":0}');
      const wiggle = getWiggleOffset(cell);
      const buildingCellPx = getBuildingCellPx(cell);
      const virtualCellPx = getVirtualCellPx(cell);
      const user = getUserState();

      // найти позицию костра в layout — это наш якорь
      let anchorSpot = layout.find(s => s.id === 'campfire');
      if(!anchorSpot){
        // fallback: геометрический центр карты (на всякий случай)
        anchorSpot = { x: (GRID_W * 0.5) - 0.5, y: (GRID_H * 0.5) - 0.5 };
      }

      const getCampfireDef = () => {
        for(const upgradeId of campfireUpgradeIds){
          if(user.unlockedResources[upgradeId]){
            return buildingById.get(upgradeId) || buildingById.get('campfire');
          }
        }
        return buildingById.get('campfire');
      };

      ctx.save();
      ctx.translate(-cam.x + wiggle.x, -cam.y + wiggle.y);

      const ordered = layout
        .map((spot) => {
          if(spot.id === 'campfire'){
            return { spot, def: getCampfireDef() };
          }
          return { spot, def: buildingById.get(spot.id) };
        })
        .filter((entry) => entry.def)
        .sort((a, b) => a.spot.y - b.spot.y);

      for(const { spot, def } of ordered){
        const unlocked = def.defaultUnlocked || user.unlockedResources[def.id];
        if(!unlocked) continue;
        drawBuilding(def, spot, cell, anchorSpot, buildingCellPx, virtualCellPx);
      }

      ctx.restore();
      requestAnimationFrame(render);
    }

    resize();
    window.addEventListener('resize', resize);
    window.addEventListener('storage', (event) => {
      if(event.key === 'map'){
        loadMap();
        resize();
      }
    });

    render();
  </script>
</body>
</html>
