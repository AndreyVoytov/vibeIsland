<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport"
        content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Hero</title>
  <style>
    html,body{margin:0;height:100%;overflow:hidden;background:transparent}
    canvas{display:block;position:absolute;top:0;left:0;touch-action:none}
  </style>
</head>
<body>
<canvas id="heroCanvas"></canvas>

<script>
/* ---------- карта ---------- */
const map = JSON.parse(localStorage.getItem('map') || '[]');
const GRID_H = map.length;
const GRID_W = map[0] ? map[0].length : 0;

/* ---------- canvas ---------- */
const canvas = document.getElementById('heroCanvas');
const ctx    = canvas.getContext('2d');

/* ---------- масштабирование ---------- */
let cw, ch, cell, pct2px = p => p * cw / 100;
const CHAR_R_PCT = 6;      // радиус головы в % ширины
const SCALE      = 0.8;    // масштаб рисунка
let charR;                 // радиус в пикселях
let footOffset;            // расстояние от головы-0,0 до стоп (px)

/* ---------- позиция / направление (координаты СТОП) ---------- */
let charXPct = 50;
let charYPct = (GRID_H / 2) / GRID_W * 100;   // центр острова
let facing   = 1;                             // 1 → вправо, −1 → влево

/* ---------- анимация ---------- */
let phase = 0, lastT = performance.now();
const WALK_FREQ = 2 * Math.PI * 1;          // 1 цикл/с
const IDLE_FREQ = 2 * Math.PI * 0.3;        // 0.3 цикла/с

/* моргание */
let blinkTimer = 0;
let nextBlink  = 2000 + Math.random() * 4000;
const BLINK_DUR = 150;

/* дополнительное замедление перемещения */
const SPEED_SCALE = 0.6;

/* ------------------------------------------------------------------ */
/*                        Р И С О В К А                               */
/* ------------------------------------------------------------------ */

/* — рюкзак + торс + голова (базовый объём) — */
function drawBody(bounce){
  /* рюкзак за спиной (слегка правее центра) */
  ctx.save();
  ctx.translate(-charR * 0.5, -bounce * 1.3);
  ctx.fillStyle = '#4e5327';
  ctx.beginPath();
  ctx.roundRect(-charR*0.3, -charR*0.2, charR*1.2, charR*1.8, charR*0.25);
  ctx.fill();
  ctx.restore();

  /* голова + торс */
  ctx.save();
  ctx.translate(0, -bounce);
  ctx.fillStyle = '#ffd15c';
  ctx.beginPath(); ctx.arc(0, 0, charR, 0, Math.PI*2); ctx.fill();               // голова
  ctx.beginPath();
  ctx.roundRect(-charR*0.25, charR*0.1, charR*0.9, charR*1.6, charR*0.25);       // торс
  ctx.fill();
  ctx.restore();
}

/* — кепка + козырёк — */
function drawCap(bounce){
  ctx.translate(0, -bounce*1.4 + charR*0.5);
  ctx.fillStyle = '#ff5151';
  ctx.beginPath();
  ctx.arc(0, -charR*0.85, charR*1.05, Math.PI, 0);                               // тулья
  ctx.fill();
  /* козырёк под углом ⇒ рисуем трапецией */
  ctx.fillRect(charR*0.8, -charR*1.05, charR*0.9, charR*0.22);
  ctx.translate(0,  bounce*1.4);
}

/* — глаза (оба) — */
function drawEyes(){
  ctx.fillStyle = '#000';
  const closed = blinkTimer > 0;
  if(closed){
    ctx.lineWidth = charR*0.08;
    const y = -charR*0.15;
    ctx.beginPath();
    ctx.moveTo(-charR*0.15, y); ctx.lineTo( charR*0.05, y);
    ctx.moveTo( charR*0.12 , y); ctx.lineTo( charR*0.14,  y);
    ctx.stroke();
  }else{
    const eyeR = charR*0.12;
    ctx.beginPath(); ctx.arc(-charR*0.05, -charR*0.15, eyeR, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc( charR*0.38, -charR*0.15, eyeR, 0, Math.PI*2); ctx.fill();
  }
}

/* — задняя (дальняя) рука без оружия — */
function drawBackArm(legSwing){
  ctx.save();
  ctx.translate(-charR*0.2, charR*0.45);
  ctx.rotate((-20 + legSwing * 25 / charR) * Math.PI/180);
  ctx.fillStyle = '#ffd15c';
  ctx.fillRect(0, -charR*0.1, charR*0.55, charR*0.2);
  ctx.restore();
}

/* — передняя рука с топором — */
function drawFrontArm(legSwing){
  ctx.save();
  ctx.translate(charR*0.5, charR*0.55);
  ctx.rotate((15 + legSwing * 35 / charR) * Math.PI/180);
  ctx.fillStyle = '#ffd15c';
  ctx.fillRect(0, -charR*0.12, charR*0.65, charR*0.25);

  /* топор */
  ctx.fillStyle = '#8b5a2b';
  ctx.fillRect(charR*0.65, -charR*0.05, charR*0.75, charR*0.1);      // рукоять
  ctx.fillStyle = '#cfd8dc';
  ctx.beginPath();
  ctx.moveTo(charR*1.4, -charR*0.3);
  ctx.lineTo(charR*1.7, 0);
  ctx.lineTo(charR*1.4,  charR*0.3);
  ctx.closePath(); ctx.fill();
  ctx.restore();
}

/* — ноги: задняя + передняя — */
function drawLegs(legSwing){
  ctx.fillStyle = '#464a4d';
  const legW = charR*0.22, legH = charR*0.9;

  /* задняя нога (стоит почти прямо) */
  ctx.fillRect(-legW/2 - charR*0 - legSwing/2, charR*1.6, legW, legH);

  /* передняя нога с раскладкой */
  ctx.save();
  ctx.translate(charR*0.18 + legSwing/2, charR*1.6);
  ctx.fillRect(-legW/2 + charR*0.15, 0, legW, legH);
  ctx.restore();
}

/* — собрать героя — */
function drawHero(anim){
  const { isMoving, phase } = anim;
  const legSwing = isMoving ? Math.sin(phase) * charR * 0.3 : 0;
  const bounce   = (isMoving ? 0.10 : 0.04) * charR * Math.abs(Math.sin(phase));

  ctx.save();
  ctx.translate(pct2px(charXPct), pct2px(charYPct));

  /* поднять рисунок на высоту стоп->0,0 */
  ctx.translate(0, -footOffset);           // footOffset не масштабируется

  /* масштаб + зеркалирование */
  ctx.scale(facing * SCALE, SCALE);

  /* слои от дальнего к ближнему */
  drawLegs(legSwing);
  drawBackArm(legSwing);
  drawBody(bounce);
  drawEyes();
  drawFrontArm(legSwing);
  drawCap(bounce);

  ctx.restore();
}
/* ------------------------------------------------------------------ */

/* ---------- логика движения / анимации ---------- */
function update(dtMs){
  const ctrl = JSON.parse(localStorage.getItem('controller')||'{}');
  let vx = (ctrl.vxPct||0) * SPEED_SCALE;
  let vy = (ctrl.vyPct||0) * SPEED_SCALE;
  const moving = Math.abs(vx)+Math.abs(vy) > 0.001;

  /* коллизия по ногам */
  if(vx){
    const nx = charXPct + vx;
    const gx = Math.floor(pct2px(nx) / cell);
    const gy = Math.floor(pct2px(charYPct) / cell);
    if(gx>=0 && gx<GRID_W && gy>=0 && gy<GRID_H && map[gy]?.[gx]) charXPct = nx;
  }
  if(vy){
    const ny = charYPct + vy;
    const gx = Math.floor(pct2px(charXPct) / cell);
    const gy = Math.floor(pct2px(ny) / cell);
    if(gx>=0 && gx<GRID_W && gy>=0 && gy<GRID_H && map[gy]?.[gx]) charYPct = ny;
  }

  /* разворот */
  if(Math.abs(vx) > 0.001) facing = vx > 0 ? 1 : -1;

  /* фаза шага */
  const dt = dtMs / 1000;
  phase += dt * (moving ? WALK_FREQ : IDLE_FREQ);
  if(phase > Math.PI*2) phase -= Math.PI*2;

  /* моргание */
  if(blinkTimer>0){
    blinkTimer -= dtMs;
  }else{
    nextBlink -= dtMs;
    if(nextBlink<=0){
      blinkTimer = BLINK_DUR;
      nextBlink  = 2000 + Math.random()*4000;
    }
  }

  return { isMoving:moving, phase };
}

/* ---------- цикл ---------- */
function frame(now){
  const dt = now - lastT; lastT = now;
  const anim = update(dt);

  ctx.clearRect(0,0,cw,ch);
  drawHero(anim);

  requestAnimationFrame(frame);
}

/* ---------- resize ---------- */
function resize(){
  cw = canvas.width  = innerWidth;
  ch = canvas.height = innerHeight;
  cell  = cw / GRID_W;
  charR = pct2px(CHAR_R_PCT);              // радиус (без учёта SCALE)
  footOffset = charR * 2;                // ~расстояние от стоп до 0,0
}
addEventListener('resize', resize);

resize();
requestAnimationFrame(frame);
</script>
</body>
</html>
