<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport"
        content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Hero Logic</title>
  <style>html,body{margin:0;height:100%;overflow:hidden;background:transparent}</style>
</head>
<body>
<script src="./buildings-config.js"></script>
<script>
/* ---------- карта ---------- */
let map = [];
let GRID_H = 0;
let GRID_W = 0;
const buildingsConfig = window.BuildingsConfig || { buildings: [], getBuildingLayout: () => [] };
const buildingDefs = buildingsConfig.buildings || [];
const buildingById = new Map(buildingDefs.map((item) => [item.id, item]));
let buildingLayout = [];

/* ---------- положение героя ---------- */
let charXPct = 50;
let charYPct = 50;
let facing   = 1;

function loadMap({ initial = false } = {}){
  const parsed = JSON.parse(localStorage.getItem('map') || '[]');
  const nextMap = Array.isArray(parsed) ? parsed : [];
  const nextH = nextMap.length;
  const nextW = nextMap[0] ? nextMap[0].length : 0;
  if(!initial && GRID_W && GRID_H && nextW && nextH){
    let shift = { x: 0, y: 0 };
    try {
      shift = JSON.parse(localStorage.getItem('mapShift') || '{"x":0,"y":0}');
    } catch (err) {
      shift = { x: 0, y: 0 };
    }
    const shiftX = Number.isFinite(shift.x) ? shift.x : 0;
    const shiftY = Number.isFinite(shift.y) ? shift.y : 0;
    const gridX = (charXPct / 100) * GRID_W + shiftX;
    const gridY = (charYPct / 100) * GRID_W + shiftY;
    charXPct = (gridX / nextW) * 100;
    charYPct = (gridY / nextW) * 100;
  }
  map = nextMap;
  GRID_H = nextH;
  GRID_W = nextW;
  buildingLayout = buildingsConfig.getBuildingLayout(map);
  if(initial && GRID_W){
    charXPct = 50;
    charYPct = (GRID_H / 2) / GRID_W * 100;
  }
}
loadMap({ initial: true });

/* скорость */
const SPEED_SCALE = 1;
const BASE_FRAME_MS = 1000 / 60;

/* вспомогалки */
function pct2pxX(p, gameW){ return p * gameW / 100; }
function pct2pxY(p, gameW){ return p * gameW / 100; } // ось Y тоже в % от ширины

function getUserState(){
  let user = {};
  try {
    user = JSON.parse(localStorage.getItem('user') || '{}');
  } catch (err) {
    user = {};
  }
  if(!user.unlockedResources || typeof user.unlockedResources !== 'object'){
    user.unlockedResources = {};
  }
  return user;
}

function getBuildingBlockers(){
  const user = getUserState();
  const blockers = new Set();
  buildingLayout.forEach((spot) => {
    const def = buildingById.get(spot.id);
    if(!def || !def.collider) return;
    const unlocked = def.defaultUnlocked || user.unlockedResources[def.id];
    if(!unlocked) return;
    const anchorX = Math.floor(spot.x);
    const anchorY = Math.floor(spot.y);
    const radius = Number.isFinite(def.colliderRadius) ? def.colliderRadius : 1;
    for(let dy = -radius; dy <= radius; dy += 1){
      for(let dx = -radius; dx <= radius; dx += 1){
        blockers.add(`${anchorX + dx},${anchorY + dy}`);
      }
    }
  });
  return blockers;
}

function applyHeroTeleport(){
  const raw = localStorage.getItem('heroTeleport');
  if(!raw) return;
  let teleport = null;
  try {
    teleport = JSON.parse(raw);
  } catch (err) {
    teleport = null;
  }
  if(!teleport || typeof teleport.xPct !== 'number' || typeof teleport.yPct !== 'number'){
    localStorage.removeItem('heroTeleport');
    return;
  }
  charXPct = teleport.xPct;
  charYPct = teleport.yPct;
  localStorage.removeItem('heroTeleport');
}

/* ---------- обновление координат ---------- */
function update(dtMs){
  applyHeroTeleport();
  const ctrl = JSON.parse(localStorage.getItem('controller') || '{}');
  const frameScale = dtMs / BASE_FRAME_MS;
  let vx = (ctrl.vxPct || 0) * SPEED_SCALE * frameScale;
  let vy = (ctrl.vyPct || 0) * SPEED_SCALE * frameScale;
  const isMoving = Math.abs(vx) + Math.abs(vy) > 0.001;

  /* коллизии по ногам (как и было) */
  const vw   = parseFloat(localStorage.getItem('gameWidth')) || innerWidth;
  const cell = vw / GRID_W;
  const blockers = getBuildingBlockers();

  let blockedByBuildingX = false;
  let blockedByBuildingY = false;

  if (vx){
    const nx = charXPct + vx;
    const gx = Math.floor(pct2pxX(nx, vw) / cell);
    const gy = Math.floor(pct2pxY(charYPct, vw) / cell);
    if (gx>=0 && gx<GRID_W && gy>=0 && gy<GRID_H && map[gy]?.[gx]){
      if(!blockers.has(`${gx},${gy}`)){
        charXPct = nx;
      } else {
        blockedByBuildingX = true;
      }
    }
  }
  if (vy){
    const ny = charYPct + vy;
    const gx = Math.floor(pct2pxX(charXPct, vw) / cell);
    const gy = Math.floor(pct2pxY(ny, vw) / cell);
    if (gx>=0 && gx<GRID_W && gy>=0 && gy<GRID_H && map[gy]?.[gx]){
      if(!blockers.has(`${gx},${gy}`)){
        charYPct = ny;
      } else {
        blockedByBuildingY = true;
      }
    }
  }

  if(blockedByBuildingX && Math.abs(vy) > 0.001){
    const slideY = charYPct + vy;
    const gx = Math.floor(pct2pxX(charXPct, vw) / cell);
    const gy = Math.floor(pct2pxY(slideY, vw) / cell);
    if (gx>=0 && gx<GRID_W && gy>=0 && gy<GRID_H && map[gy]?.[gx] && !blockers.has(`${gx},${gy}`)){
      charYPct = slideY;
    }
  }
  if(blockedByBuildingY && Math.abs(vx) > 0.001){
    const slideX = charXPct + vx;
    const gx = Math.floor(pct2pxX(slideX, vw) / cell);
    const gy = Math.floor(pct2pxY(charYPct, vw) / cell);
    if (gx>=0 && gx<GRID_W && gy>=0 && gy<GRID_H && map[gy]?.[gx] && !blockers.has(`${gx},${gy}`)){
      charXPct = slideX;
    }
  }

  if (Math.abs(vx) > 0.001) facing = vx > 0 ? 1 : -1;

  /* публикуем состояние героя */
  localStorage.setItem('heroState', JSON.stringify({ charXPct, charYPct, facing, isMoving }));

  /* —— камера: всегда держим героя в центре экрана (без клампа) —— */
  const ghCam = parseFloat(localStorage.getItem('gameHeight')) || innerHeight;
  const vwCam = parseFloat(localStorage.getItem('gameWidth'))  || innerWidth;
  const worldW = vwCam;                              // логика мира остаётся прежней
  const worldH = vwCam * (GRID_H / GRID_W);          // ось Y в % от ширины

  const heroX = pct2pxX(charXPct, vwCam);
  const heroY = pct2pxY(charYPct, vwCam);

  // Камера — центр на герое, без ограничений, чтобы остров «ездил» под ним.
  const camX = heroX - vwCam/2;
  const camY = heroY - ghCam/2;

  localStorage.setItem('camera', JSON.stringify({x:camX, y:camY}));
}

/* ---------- цикл ---------- */
let lastT = performance.now();
function frame(now){
  const dt = now - lastT; lastT = now;
  update(dt);
  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);

window.addEventListener('storage', (event) => {
  if(event.key === 'map'){
    loadMap();
  }
});
</script>
</body>
</html>
