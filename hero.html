<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport"
        content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Hero Logic</title>
  <style>html,body{margin:0;height:100%;overflow:hidden;background:transparent}</style>
</head>
<body>
<script src="./buildings-config.js"></script>
<script>
/* ---------- карта ---------- */
let map = [];
let GRID_H = 0;
let GRID_W = 0;
const buildingsConfig = window.BuildingsConfig || { buildings: [], getBuildingLayout: () => [] };
const buildingDefs = buildingsConfig.buildings || [];
const buildingById = new Map(buildingDefs.map((item) => [item.id, item]));
let buildingLayout = [];

/* ---------- положение героя ---------- */
let charXPct = 50;
let charYPct = 50;
let facing   = 1;

function loadMap({ initial = false } = {}){
  const parsed = JSON.parse(localStorage.getItem('map') || '[]');
  const nextMap = Array.isArray(parsed) ? parsed : [];
  const nextH = nextMap.length;
  const nextW = nextMap[0] ? nextMap[0].length : 0;
  if(!initial && GRID_W && GRID_H && nextW && nextH){
    let shift = { x: 0, y: 0 };
    try {
      shift = JSON.parse(localStorage.getItem('mapShift') || '{"x":0,"y":0}');
    } catch (err) {
      shift = { x: 0, y: 0 };
    }
    const shiftX = Number.isFinite(shift.x) ? shift.x : 0;
    const shiftY = Number.isFinite(shift.y) ? shift.y : 0;
    const gridX = (charXPct / 100) * GRID_W + shiftX;
    const gridY = (charYPct / 100) * GRID_W + shiftY;
    charXPct = (gridX / nextW) * 100;
    charYPct = (gridY / nextW) * 100;
  }
  map = nextMap;
  GRID_H = nextH;
  GRID_W = nextW;
  buildingLayout = buildingsConfig.getBuildingLayout(map);
  if(initial && GRID_W){
    charXPct = 50;
    charYPct = (GRID_H / 2) / GRID_W * 100;
  }
}
loadMap({ initial: true });

/* скорость */
const SPEED_SCALE = 1;
const BASE_FRAME_MS = 1000 / 60;

/* вспомогалки */
function pct2pxX(p, gameW){ return p * gameW / 100; }
function pct2pxY(p, gameW){ return p * gameW / 100; } // ось Y тоже в % от ширины

function getUserState(){
  let user = {};
  try {
    user = JSON.parse(localStorage.getItem('user') || '{}');
  } catch (err) {
    user = {};
  }
  if(!user.unlockedResources || typeof user.unlockedResources !== 'object'){
    user.unlockedResources = {};
  }
  return user;
}

function getVirtualCellPx(){
  const value = buildingsConfig.virtualCellPx;
  return Number.isFinite(value) ? value : 28;
}

function getBuildingAnchorSpot(){
  let anchorSpot = buildingLayout.find((spot) => spot.id === 'campfire');
  if(anchorSpot) return anchorSpot;
  if(GRID_W && GRID_H){
    return { x: (GRID_W * 0.5) - 0.5, y: (GRID_H * 0.5) - 0.5 };
  }
  return null;
}

function getBuildingBlockers(cellPx){
  const user = getUserState();
  const blockers = new Set();
  if(!cellPx || !GRID_W) return blockers;
  const anchorSpot = getBuildingAnchorSpot();
  if(!anchorSpot) return blockers;
  const virtualCellPx = getVirtualCellPx();
  const anchorX = (anchorSpot.x + 0.5) * cellPx;
  const anchorY = (anchorSpot.y + 0.5) * cellPx;

  buildingLayout.forEach((spot) => {
    const def = buildingById.get(spot.id);
    if(!def || !def.collider) return;
    const unlocked = def.defaultUnlocked || user.unlockedResources[def.id];
    if(!unlocked) return;
    const radius = Number.isFinite(def.colliderRadius) ? def.colliderRadius : 1;
    const centerX = anchorX + (spot.x - anchorSpot.x) * virtualCellPx;
    const centerY = anchorY + (spot.y - anchorSpot.y) * virtualCellPx;
    const gridX = Math.floor(centerX / cellPx);
    const gridY = Math.floor(centerY / cellPx);
    const radiusCells = Math.max(1, Math.round((radius * virtualCellPx) / cellPx));
    for(let dy = -radiusCells; dy <= radiusCells; dy += 1){
      for(let dx = -radiusCells; dx <= radiusCells; dx += 1){
        blockers.add(`${gridX + dx},${gridY + dy}`);
      }
    }
  });
  return blockers;
}

let resourceBlockersCache = new Set();
let resourceBlockersUpdatedAt = 0;

function getResourceBlockers(){
  const updatedAt = Number(localStorage.getItem('resourceColliderUpdatedAt') || 0);
  if(updatedAt && updatedAt === resourceBlockersUpdatedAt){
    return resourceBlockersCache;
  }
  resourceBlockersUpdatedAt = updatedAt;
  const raw = localStorage.getItem('resourceColliderCells');
  if(!raw){
    resourceBlockersCache = new Set();
    return resourceBlockersCache;
  }
  try {
    const parsed = JSON.parse(raw);
    resourceBlockersCache = new Set(Array.isArray(parsed) ? parsed : []);
  } catch (err) {
    resourceBlockersCache = new Set();
  }
  return resourceBlockersCache;
}

let scenarioBlockersCache = new Set();
let scenarioBlockersUpdatedAt = 0;

function getScenarioBlockers(){
  const updatedAt = Number(localStorage.getItem('scenarioColliderUpdatedAt') || 0);
  if(updatedAt && updatedAt === scenarioBlockersUpdatedAt){
    return scenarioBlockersCache;
  }
  scenarioBlockersUpdatedAt = updatedAt;
  const raw = localStorage.getItem('scenarioColliderCells');
  if(!raw){
    scenarioBlockersCache = new Set();
    return scenarioBlockersCache;
  }
  try {
    const parsed = JSON.parse(raw);
    scenarioBlockersCache = new Set(Array.isArray(parsed) ? parsed : []);
  } catch (err) {
    scenarioBlockersCache = new Set();
  }
  return scenarioBlockersCache;
}

function applyHeroTeleport(){
  const raw = localStorage.getItem('heroTeleport');
  if(!raw) return;
  let teleport = null;
  try {
    teleport = JSON.parse(raw);
  } catch (err) {
    teleport = null;
  }
  if(!teleport || typeof teleport.xPct !== 'number' || typeof teleport.yPct !== 'number'){
    localStorage.removeItem('heroTeleport');
    return;
  }
  charXPct = teleport.xPct;
  charYPct = teleport.yPct;
  localStorage.removeItem('heroTeleport');
}

/* ---------- обновление координат ---------- */
function update(dtMs){
  applyHeroTeleport();
  const ctrl = JSON.parse(localStorage.getItem('controller') || '{}');
  const frameScale = dtMs / BASE_FRAME_MS;
  let vx = (ctrl.vxPct || 0) * SPEED_SCALE * frameScale;
  let vy = (ctrl.vyPct || 0) * SPEED_SCALE * frameScale;
  const isMoving = Math.abs(vx) + Math.abs(vy) > 0.001;

  /* коллизии по ногам (как и было) */
  const vw   = parseFloat(localStorage.getItem('gameWidth')) || innerWidth;
  const cell = vw / GRID_W;
  const blockers = getBuildingBlockers(cell);
  const resourceBlockers = getResourceBlockers();
  const scenarioBlockers = getScenarioBlockers();

  let blockedByBuildingX = false;
  let blockedByBuildingY = false;
  let movedX = false;
  let movedY = false;

  if (vx){
    const nx = charXPct + vx;
    const gx = Math.floor(pct2pxX(nx, vw) / cell);
    const gy = Math.floor(pct2pxY(charYPct, vw) / cell);
    if (gx>=0 && gx<GRID_W && gy>=0 && gy<GRID_H && map[gy]?.[gx]){
      if(!blockers.has(`${gx},${gy}`) && !resourceBlockers.has(`${gx},${gy}`) && !scenarioBlockers.has(`${gx},${gy}`)){
        charXPct = nx;
        movedX = true;
      } else {
        blockedByBuildingX = true;
      }
    }
  }
  if (vy){
    const ny = charYPct + vy;
    const gx = Math.floor(pct2pxX(charXPct, vw) / cell);
    const gy = Math.floor(pct2pxY(ny, vw) / cell);
    if (gx>=0 && gx<GRID_W && gy>=0 && gy<GRID_H && map[gy]?.[gx]){
      if(!blockers.has(`${gx},${gy}`) && !resourceBlockers.has(`${gx},${gy}`) && !scenarioBlockers.has(`${gx},${gy}`)){
        charYPct = ny;
        movedY = true;
      } else {
        blockedByBuildingY = true;
      }
    }
  }

  if(blockedByBuildingX && !movedY && Math.abs(vy) > 0.001){
    const slideY = charYPct + vy;
    const gx = Math.floor(pct2pxX(charXPct, vw) / cell);
    const gy = Math.floor(pct2pxY(slideY, vw) / cell);
    if (gx>=0 && gx<GRID_W && gy>=0 && gy<GRID_H && map[gy]?.[gx] && !blockers.has(`${gx},${gy}`) && !resourceBlockers.has(`${gx},${gy}`) && !scenarioBlockers.has(`${gx},${gy}`)){
      charYPct = slideY;
      movedY = true;
    }
  }
  if(blockedByBuildingY && !movedX && Math.abs(vx) > 0.001){
    const slideX = charXPct + vx;
    const gx = Math.floor(pct2pxX(slideX, vw) / cell);
    const gy = Math.floor(pct2pxY(charYPct, vw) / cell);
    if (gx>=0 && gx<GRID_W && gy>=0 && gy<GRID_H && map[gy]?.[gx] && !blockers.has(`${gx},${gy}`) && !resourceBlockers.has(`${gx},${gy}`) && !scenarioBlockers.has(`${gx},${gy}`)){
      charXPct = slideX;
      movedX = true;
    }
  }

  if (Math.abs(vx) > 0.001) facing = vx > 0 ? 1 : -1;

  /* публикуем состояние героя */
  localStorage.setItem('heroState', JSON.stringify({ charXPct, charYPct, facing, isMoving }));

  /* —— камера: всегда держим героя в центре экрана (без клампа) —— */
  const ghCam = parseFloat(localStorage.getItem('gameHeight')) || innerHeight;
  const vwCam = parseFloat(localStorage.getItem('gameWidth'))  || innerWidth;
  const worldW = vwCam;                              // логика мира остаётся прежней
  const worldH = vwCam * (GRID_H / GRID_W);          // ось Y в % от ширины

  const heroX = pct2pxX(charXPct, vwCam);
  const heroY = pct2pxY(charYPct, vwCam);

  // Камера — центр на герое, без ограничений, чтобы остров «ездил» под ним.
  const camX = heroX - vwCam/2;
  const camY = heroY - ghCam/2;

  localStorage.setItem('camera', JSON.stringify({x:camX, y:camY}));
}

/* ---------- цикл ---------- */
let lastT = performance.now();
function frame(now){
  const dt = now - lastT; lastT = now;
  update(dt);
  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);

window.addEventListener('storage', (event) => {
  if(event.key === 'map'){
    loadMap();
  }
});
</script>
</body>
</html>
