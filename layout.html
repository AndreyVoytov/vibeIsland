<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport"
        content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Layout</title>
  <style>
    html,body{margin:0;height:100%;overflow:hidden;background:#000}
    canvas{display:block;touch-action:none}
  </style>
</head>
<body>
<canvas id="mapCanvas"></canvas>

<script>
const map = JSON.parse(localStorage.getItem('map') || '[]');
const GRID_H = map.length;
const GRID_W = map[0] ? map[0].length : 0;
const H_PCT = (GRID_H/GRID_W) * 100;

function getCam(){ return JSON.parse(localStorage.getItem('camera') || '{"x":0,"y":0}'); }

/* canvas */
const canvas = document.getElementById('mapCanvas');
const ctx    = canvas.getContext('2d');
let cw=0, ch=0;
function pct2px(p){ return p*cw/100; }

// === Shadow under island: config ===
const SHADOW_ASSET_URL = ''; // e.g. './images/island_shadow.png' — if contains 'images', image will be used
const SHADOW_COLOR = 'rgb(12, 32, 92)';
const SHADOW_OPACITY = 0.35;
const SHADOW_PADDING_X = 0.05;
const SHADOW_PADDING_Y = 0.09;
const SHADOW_OFFSET_Y = 0.01;
const SHADOW_RADIUS   = 0.05;
// === end config ===

// === Tile image (optional) ===
const TILE_ASSET_URL = ''; // e.g. './images/tile.png' — if contains 'images', image will be used
const TILE_IMG_OPACITY = 1.0;
const TILE_IMG_ROUNDED = true; // clip to rounded rect same as primitive tiles
// === end config ===

/* === SHARKS (safe spawn away from island) === */
const sharks = [];
const SHARK_N = 5;
const SHARK_WANDER_R = 7;     // радиус блуждания (в % ширины)
const SHARK_SAFE_FACTOR = 1.5; // спавн не ближе чем 1.5*R к тайлам
const SHARK_ANG_SPEED_MIN = 0.0006;
const SHARK_ANG_SPEED_MAX = 0.0016;

// расстояние от точки до прямоугольника в тех же единицах (проценты)
function distPointRect(px, py, rx, ry, rw, rh){
  const dx = Math.max(rx - px, 0, px - (rx + rw));
  const dy = Math.max(ry - py, 0, py - (ry + rh));
  return Math.hypot(dx, dy);
}

// bbox острова в процентах (0..100 по X, 0..H_PCT по Y)
function getIslandBBoxPct(){
  if(!GRID_W || !GRID_H) return null;
  let minGX=Infinity, minGY=Infinity, maxGX=-Infinity, maxGY=-Infinity;
  for(let y=0;y<GRID_H;y++)for(let x=0;x<GRID_W;x++){
    if(map[y]?.[x]){
      if(x<minGX) minGX=x;
      if(y<minGY) minGY=y;
      if(x+1>maxGX) maxGX=x+1;
      if(y+1>maxGY) maxGY=y+1;
    }
  }
  if(!isFinite(minGX)) return null;
  const xPct = (minGX/GRID_W)*100;
  const yPct = (minGY/GRID_W)*100; // важно: приводим к % от ширины
  const wPct = ((maxGX-minGX)/GRID_W)*100;
  const hPct = ((maxGY-minGY)/GRID_W)*100; // тоже от ширины
  return {xPct, yPct, wPct, hPct};
}

// случайное число в [a,b]
function rand(a,b){ return a + Math.random()*(b-a); }

function spawnSharks(){
  sharks.length = 0;
  const bbox = getIslandBBoxPct();
  for(let i=0;i<SHARK_N;i++){
    let tries = 0;
    let sx=0, sy=0, ok=false;
    const R = SHARK_WANDER_R;
    // ограничим спавн так, чтобы круг блуждания оставался в пределах моря
    while(tries++<200 && !ok){
      sx = rand(R, 100 - R);
      sy = rand(R, H_PCT - R);
      // если есть остров — соблюдаем безопасную дистанцию
      let safe = true;
      if(bbox){
        const d = distPointRect(sx, sy, bbox.xPct, bbox.yPct, bbox.wPct, bbox.hPct);
        if(d < SHARK_SAFE_FACTOR * R) safe = false;
      }
      ok = safe;
    }
    const phase = Math.random()*Math.PI*2;
    const angSpeed = rand(SHARK_ANG_SPEED_MIN, SHARK_ANG_SPEED_MAX);
    sharks.push({
      sxPct: sx, syPct: sy,
      R: SHARK_WANDER_R,
      angle: Math.random()*Math.PI*2,
      angSpeed,
      phase,
      xPct: sx, yPct: sy
    });
  }
}

function updateSharks(dt){
  const bbox = getIslandBBoxPct();
  sharks.forEach(s=>{
    s.angle += s.angSpeed * dt;
    const x = s.sxPct + Math.cos(s.angle) * s.R;
    const y = s.syPct + Math.sin(s.angle*1.25 + s.phase) * (s.R*0.65);
    s.xPct = Math.max(0, Math.min(100, x));
    s.yPct = Math.max(0, Math.min(H_PCT, y));
    // на всякий случай мягко отталкиваемся, если кто-то оказался слишком близко (численно)
    if(bbox){
      const d = distPointRect(s.xPct, s.yPct, bbox.xPct, bbox.yPct, bbox.wPct, bbox.hPct);
      const minD = SHARK_SAFE_FACTOR * s.R * 0.98;
      if(d < minD){
        // вектор от центра прямоугольника к акуле
        const cx = bbox.xPct + bbox.wPct/2;
        const cy = bbox.yPct + bbox.hPct/2;
        let vx = s.xPct - cx, vy = s.yPct - cy;
        const len = Math.hypot(vx,vy) || 1;
        vx/=len; vy/=len;
        const push = (minD - d);
        s.xPct += vx * push;
        s.yPct += vy * push;
      }
    }
  });
}

function drawSharks(cam){
  ctx.save(); ctx.translate(-cam.x,-cam.y);
  sharks.forEach(s=>{
    const x = pct2px(s.xPct), y = pct2px(s.yPct);
    // пена
    ctx.save(); ctx.globalAlpha=0.5; ctx.beginPath(); ctx.ellipse(x, y+4, 16, 6, 0, 0, Math.PI*2); ctx.fillStyle='#fff'; ctx.fill(); ctx.restore();
    // плавник
    ctx.save(); ctx.translate(x,y);
    // направление — по производной от угла
    const dx = -Math.sin(s.angle), dy = Math.cos(s.angle*1.25 + s.phase)*1.25;
    if(dx<0) ctx.scale(-1,1);
    ctx.beginPath(); ctx.moveTo(-10,6); ctx.lineTo(0,-16); ctx.lineTo(10,6); ctx.closePath(); ctx.fillStyle='#0a2a66'; ctx.fill();
    ctx.restore();
  });
  ctx.restore();
}
/* === end sharks === */

/* море */
function drawSea(){ ctx.fillStyle='#1e6fff'; ctx.fillRect(0,0,cw,ch); }

/* большая «тень» под островом (замена: глубокий тёмно-синий скруглённый прямоугольник)
   * Можно заменить на картинку, указав URL (если содержит 'images', будет использовано изображение).
   */

function drawIslandUnderShadow(cam){
  // Find island bounding box in canvas space
  let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
  const cell = cw/GRID_W || 0;
  for(let y=0;y<GRID_H;y++) for(let x=0;x<GRID_W;x++) if(map[y]?.[x]){
    minX=Math.min(minX,x*cell); minY=Math.min(minY,y*cell);
    maxX=Math.max(maxX,(x+1)*cell); maxY=Math.max(maxY,(y+1)*cell);
  }
  if(!isFinite(minX)) return;

  const w=maxX-minX, h=maxY-minY;
  const padX = w*SHADOW_PADDING_X, padY = h*SHADOW_PADDING_Y;
  const x = minX - padX;
  const y = minY - padY*0.5 + h * SHADOW_OFFSET_Y;
  const ww = w + padX*2;
  const hh = h + padY;
  const radius = Math.min(ww,hh) * SHADOW_RADIUS;

  const useShadowImg = (typeof SHADOW_ASSET_URL==='string') && SHADOW_ASSET_URL.includes('images');
  ctx.save();
  ctx.translate(-cam.x, -cam.y);

  if(useShadowImg){
    const img = drawIslandUnderShadow._img || (drawIslandUnderShadow._img = new Image());
    if(!img.src) img.src = SHADOW_ASSET_URL;
    if(img.complete && img.naturalWidth>0){
      ctx.drawImage(img, x, y, ww, hh);
    }else{
      ctx.globalAlpha = SHADOW_OPACITY*0.5;
      ctx.fillStyle = SHADOW_COLOR;
      if (ctx.roundRect){ ctx.beginPath(); ctx.roundRect(x,y,ww,hh, radius); ctx.fill(); }
      else { ctx.beginPath(); ctx.ellipse(x+ww/2,y+hh/2,ww*0.5,hh*0.5,0,0,Math.PI*2); ctx.fill(); }
    }
  }else{
    ctx.globalAlpha = SHADOW_OPACITY;
    ctx.fillStyle = SHADOW_COLOR;
    if (ctx.roundRect){
      ctx.beginPath();
      ctx.roundRect(x, y, ww, hh, radius);
      ctx.fill();
    }else{
      ctx.beginPath();
      ctx.ellipse(x+ww/2, y+hh*0.5, ww*0.5, hh*0.5, 0, 0, Math.PI*2);
      ctx.fill();
    }
  }

  ctx.restore();
}

/* остров: перекрывающиеся тайлы + «срез» или картинка тайла */
function drawIsland(cam){
  const cell = cw/GRID_W || 0, radius = cell*0.22, overlap = cell*0.12;

  ctx.save(); ctx.translate(-cam.x,-cam.y);

  // мягкая тень каждого тайла (стала чуть мягче и круглее)
  ctx.fillStyle='rgba(0,0,0,0.16)';
  for(let y=0;y<GRID_H;y++)for(let x=0;x<GRID_W;x++) if(map[y]?.[x]){
    ctx.beginPath();
    if(ctx.roundRect) ctx.roundRect(x*cell - overlap/2, (y*cell)+cell*0.24 - overlap/2, cell+overlap, cell+overlap, radius);
    else { ctx.rect(x*cell - overlap/2, (y*cell)+cell*0.24 - overlap/2, cell+overlap, cell+overlap); }
    ctx.fill();
  }

  const useTileImg = (typeof TILE_ASSET_URL==='string') && TILE_ASSET_URL.includes('images');
  if(useTileImg){
    // рисуем изображение на каждом тайле с клипом по скруглённому прямоугольнику
    const img = drawIsland._tileImg || (drawIsland._tileImg = new Image());
    if(!img.src) img.src = TILE_ASSET_URL;
    for(let y=0;y<GRID_H;y++)for(let x=0;x<GRID_W;x++) if(map[y]?.[x]){
      const sx = x*cell - overlap/2;
      const sy = y*cell - overlap/2;
      const ww = cell + overlap;
      const hh = cell + overlap;
      ctx.save();
      ctx.globalAlpha = TILE_IMG_OPACITY;
      if(TILE_IMG_ROUNDED && ctx.roundRect){
        ctx.beginPath();
        ctx.roundRect(sx, sy, ww, hh, radius);
        ctx.clip();
      }
      if(img.complete && img.naturalWidth>0){
        ctx.drawImage(img, sx, sy, ww, hh);
      }else{
        // заглушка пока картинка грузится
        ctx.fillStyle = '#2fb84b';
        ctx.fillRect(sx, sy, ww, hh);
      }
      ctx.restore();
    }
  }else{
    // верхняя поверхность — зелёная трава (примитивы)
    ctx.fillStyle='#2fb84b';
    for(let y=0;y<GRID_H;y++)for(let x=0;x<GRID_W;x++) if(map[y]?.[x]){
      ctx.beginPath();
      if(ctx.roundRect) ctx.roundRect(x*cell - overlap/2, y*cell - overlap/2, cell+overlap, cell+overlap, radius);
      else { ctx.rect(x*cell - overlap/2, y*cell - overlap/2, cell+overlap, cell+overlap); }
      ctx.fill();
    }

    // Детальный «срез»: тёмно-зелёная кромка, затем зелёная кромка, затем коричневая земля и тонкая белая пена
    const dkG = '#1f8a3a';  // тёмно-зелёный
    const ltG = '#2fb84b';  // светло-зелёный (та же трава)
    const earth = '#8a5a2b'; // коричневый
    const foam  = 'rgba(255,255,255,0.85)';

    const bandDk = cell*0.035;
    const bandLt = cell*0.030;
    const bandEarth = cell*0.12;
    const bandFoam  = cell*0.020;

    for(let y=0;y<GRID_H;y++)for(let x=0;x<GRID_W;x++) if(map[y]?.[x]){
      // НИЖНИЙ КРАЙ
      if(!map[y+1] || !map[y+1][x]){
        const sx = x*cell, sy = (y+1)*cell;
        // Тёмно-зелёный кант
        ctx.fillStyle = dkG;
        ctx.fillRect(sx, sy, cell, bandDk);
        // Светло-зелёный кант
        ctx.fillStyle = ltG;
        ctx.fillRect(sx, sy + bandDk, cell, bandLt);
        // Земля (толще, с лёгким затемнением к низу)
        const g = ctx.createLinearGradient(0, sy+bandDk+bandLt, 0, sy+bandDk+bandLt+bandEarth);
        g.addColorStop(0, earth);
        g.addColorStop(1, '#6f4424');
        ctx.fillStyle = g;
        ctx.fillRect(sx, sy + bandDk + bandLt, cell, bandEarth);
        // Пена (тонкая белая полоса с лёгкой «рваностью»)
        ctx.save();
        ctx.fillStyle = foam;
        const px = 4, py = 2;
        for(let i=0;i<cell;i+=px){
          const jitter = (Math.sin((i+sx)*0.07)*0.5 + Math.random()*0.25) * py;
          ctx.fillRect(sx+i, sy + bandDk + bandLt + bandEarth + jitter, px, bandFoam);
        }
        ctx.restore();
      }

      // ПРАВЫЙ КРАЙ
      if(!map[y][x+1]){
        const sx = (x+1)*cell, sy = y*cell;
        // Тёмно-зелёный кант
        ctx.fillStyle = dkG;
        ctx.fillRect(sx, sy, bandDk, cell);
        // Светло-зелёный кант
        ctx.fillStyle = ltG;
        ctx.fillRect(sx + bandDk, sy, bandLt, cell);
        // Земля
        const g = ctx.createLinearGradient(sx + bandDk + bandLt, 0, sx + bandDk + bandLt + bandEarth, 0);
        g.addColorStop(0, earth);
        g.addColorStop(1, '#6f4424');
        ctx.fillStyle = g;
        ctx.fillRect(sx + bandDk + bandLt, sy, bandEarth, cell);
        // Пена
        ctx.save();
        ctx.fillStyle = foam;
        const px = 2, py = 4;
        for(let j=0;j<cell;j+=py){
          const jitter = (Math.cos((j+sy)*0.09)*0.5 + Math.random()*0.25) * px;
          ctx.fillRect(sx + bandDk + bandLt + bandEarth + jitter, sy + j, bandFoam, py);
        }
        ctx.restore();
      }
    }
  }

  ctx.restore();
}

/* кадр */
let last = performance.now();
function frame(now){
  const dt = now - last; last = now;
  updateSharks(dt);

  ctx.clearRect(0,0,cw,ch);
  drawSea();

  const cam = getCam();
  drawIslandUnderShadow(cam);
  drawSharks(cam);
  drawIsland(cam);

  requestAnimationFrame(frame);
}

/* resize/init */
function resize(){ canvas.width = innerWidth; canvas.height = innerHeight; cw=canvas.width; ch=canvas.height; }
addEventListener('resize',resize); resize(); spawnSharks(); requestAnimationFrame(frame);
</script>
</body>
</html>
