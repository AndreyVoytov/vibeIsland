<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport"
        content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Layout Island</title>
  <style>
    html,body{margin:0;height:100%;overflow:hidden;background:transparent}
    canvas{display:block;touch-action:none}
  </style>
</head>
<body>
<canvas id="islandCanvas"></canvas>

<script>
let map = [];
let GRID_H = 0;
let GRID_W = 0;

function loadMap(){
  try {
    const stored = JSON.parse(localStorage.getItem('map') || '[]');
    map = Array.isArray(stored) ? stored : [];
  } catch (err) {
    map = [];
  }
  GRID_H = map.length;
  GRID_W = map[0] ? map[0].length : 0;
}
loadMap();

function getCam(){ return JSON.parse(localStorage.getItem('camera') || '{"x":0,"y":0}'); }
function getWiggleOffset(){
  const start = Number(localStorage.getItem('islandWiggleAt') || 0);
  if(!start) return { x: 0, y: 0 };
  const duration = 700;
  const elapsed = performance.now() - start;
  if(elapsed < 0 || elapsed > duration) return { x: 0, y: 0 };
  const t = elapsed / duration;
  const decay = 1 - t;
  const cell = GRID_W ? cw / GRID_W : 0;
  return {
    x: Math.sin(t * Math.PI * 4) * cell * 0.12 * decay,
    y: Math.cos(t * Math.PI * 4) * cell * 0.08 * decay,
  };
}

/* canvas */
const canvas = document.getElementById('islandCanvas');
const ctx    = canvas.getContext('2d');
let cw=0, ch=0;

// === Shadow under island: config ===
const SHADOW_ASSET_URL = ''; // e.g. './images/island_shadow.png' — if contains 'images', image will be used
const SHADOW_COLOR = 'rgb(12, 32, 92)';
const SHADOW_OPACITY = 0.35;
const SHADOW_PADDING_X = 0.04;
const SHADOW_PADDING_Y = 0.09;
const SHADOW_OFFSET_Y = 0.015;
const SHADOW_RADIUS   = 0.02;
// === end config ===

// === Tile image (optional) ===
const TILE_ASSET_URL = './img/tiles/1.png'; // e.g. './images/tile.png' — if contains 'images', image will be used
const TILE_IMG_OPACITY = 1.0;
const TILE_IMG_ROUNDED = true; // clip to rounded rect same as primitive tiles
// === end config ===

/* большая «тень» под островом (замена: глубокий тёмно-синий скруглённый прямоугольник)
   * Можно заменить на картинку, указав URL (если содержит 'images', будет использовано изображение).
   */

function drawIslandUnderShadow(cam, wiggle){
  // Find island bounding box in canvas space
  let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
  const cell = cw/GRID_W || 0;
  for(let y=0;y<GRID_H;y++) for(let x=0;x<GRID_W;x++) if(map[y]?.[x]){
    minX=Math.min(minX,x*cell); minY=Math.min(minY,y*cell);
    maxX=Math.max(maxX,(x+1)*cell); maxY=Math.max(maxY,(y+1)*cell);
  }
  if(!isFinite(minX)) return;

  const w=maxX-minX, h=maxY-minY;
  const padX = w*SHADOW_PADDING_X, padY = h*SHADOW_PADDING_Y;
  const x = minX - padX;
  const y = minY - padY*0.5 + h * SHADOW_OFFSET_Y;
  const ww = w + padX*2;
  const hh = h + padY;
  const radius = Math.min(ww,hh) * SHADOW_RADIUS;

  const useShadowImg = (typeof SHADOW_ASSET_URL==='string') && SHADOW_ASSET_URL.includes('images');
  ctx.save();
  ctx.translate(-cam.x + wiggle.x, -cam.y + wiggle.y);

  if(useShadowImg){
    const img = drawIslandUnderShadow._img || (drawIslandUnderShadow._img = new Image());
    if(!img.src) img.src = SHADOW_ASSET_URL;
    if(img.complete && img.naturalWidth>0){
      ctx.drawImage(img, x, y, ww, hh);
    }else{
      ctx.globalAlpha = SHADOW_OPACITY*0.5;
      ctx.fillStyle = SHADOW_COLOR;
      if (ctx.roundRect){ ctx.beginPath(); ctx.roundRect(x,y,ww,hh, radius); ctx.fill(); }
      else { ctx.beginPath(); ctx.ellipse(x+ww/2,y+hh/2,ww*0.5,hh*0.5,0,0,Math.PI*2); ctx.fill(); }
    }
  }else{
    ctx.globalAlpha = SHADOW_OPACITY;
    ctx.fillStyle = SHADOW_COLOR;
    if (ctx.roundRect){
      ctx.beginPath();
      ctx.roundRect(x, y, ww, hh, radius);
      ctx.fill();
    }else{
      ctx.beginPath();
      ctx.ellipse(x+ww/2, y+hh*0.5, ww*0.5, hh*0.5, 0, 0, Math.PI*2);
      ctx.fill();
    }
  }

  ctx.restore();
}

/* остров: перекрывающиеся тайлы + «срез» или картинка тайла */
function drawIsland(cam, wiggle){
  const cell = cw/GRID_W || 0, radius = cell*0.22, overlap = cell*0.12;

  ctx.save(); ctx.translate(-cam.x + wiggle.x, -cam.y + wiggle.y);

  // мягкая тень каждого тайла (стала чуть мягче и круглее)
  ctx.fillStyle='rgba(0,0,0,0.16)';
  for(let y=0;y<GRID_H;y++)for(let x=0;x<GRID_W;x++) if(map[y]?.[x]){
    ctx.beginPath();
    if(ctx.roundRect) ctx.roundRect(x*cell - overlap/2, (y*cell)+cell*0.24 - overlap/2, cell+overlap, cell+overlap, radius);
    else { ctx.rect(x*cell - overlap/2, (y*cell)+cell*0.24 - overlap/2, cell+overlap, cell+overlap); }
    ctx.fill();
  }

  const useTileImg = (typeof TILE_ASSET_URL==='string') && TILE_ASSET_URL.includes('img');
  if(useTileImg){
    // рисуем изображение на каждом тайле с клипом по скруглённому прямоугольнику
    const img = drawIsland._tileImg || (drawIsland._tileImg = new Image());
    if(!img.src) img.src = TILE_ASSET_URL;
    for(let y=0;y<GRID_H;y++)for(let x=0;x<GRID_W;x++) if(map[y]?.[x]){
      const sx = x*cell - overlap/2;
      const sy = y*cell - overlap/2;
      const ww = cell + overlap;
      const hh = cell + overlap;
      ctx.save();
      ctx.globalAlpha = TILE_IMG_OPACITY;
      if(TILE_IMG_ROUNDED && ctx.roundRect){
        ctx.beginPath();
        ctx.roundRect(sx, sy, ww, hh + 10, radius);
        ctx.clip();
      }
      if(img.complete && img.naturalWidth>0){
        ctx.drawImage(img, sx, sy, ww, hh + 10);
      }else{
        // заглушка пока картинка грузится
        ctx.fillStyle = '#2fb84b';
        ctx.fillRect(sx, sy, ww, hh);
      }
      ctx.restore();
    }
  }else{
    // верхняя поверхность — зелёная трава (примитивы)
    ctx.fillStyle='#2fb84b';
    for(let y=0;y<GRID_H;y++)for(let x=0;x<GRID_W;x++) if(map[y]?.[x]){
      ctx.beginPath();
      if(ctx.roundRect) ctx.roundRect(x*cell - overlap/2, y*cell - overlap/2, cell+overlap, cell+overlap, radius);
      else { ctx.rect(x*cell - overlap/2, y*cell - overlap/2, cell+overlap, cell+overlap); }
      ctx.fill();
    }

    // Детальный «срез»: тёмно-зелёная кромка, затем зелёная кромка, затем коричневая земля и тонкая белая пена
    const dkG = '#1f8a3a';  // тёмно-зелёный
    const ltG = '#2fb84b';  // светло-зелёный (та же трава)
    const earth = '#8a5a2b'; // коричневый
    const foam  = 'rgba(255,255,255,0.85)';

    const bandDk = cell*0.035;
    const bandLt = cell*0.030;
    const bandEarth = cell*0.12;
    const bandFoam  = cell*0.020;

    for(let y=0;y<GRID_H;y++)for(let x=0;x<GRID_W;x++) if(map[y]?.[x]){
      // НИЖНИЙ КРАЙ
      if(!map[y+1] || !map[y+1][x]){
        const sx = x*cell, sy = (y+1)*cell;
        // Тёмно-зелёный кант
        ctx.fillStyle = dkG;
        ctx.fillRect(sx, sy, cell, bandDk);
        // Светло-зелёный кант
        ctx.fillStyle = ltG;
        ctx.fillRect(sx, sy + bandDk, cell, bandLt);
        // Земля (толще, с лёгким затемнением к низу)
        const g = ctx.createLinearGradient(0, sy+bandDk+bandLt, 0, sy+bandDk+bandLt+bandEarth);
        g.addColorStop(0, earth);
        g.addColorStop(1, '#6f4424');
        ctx.fillStyle = g;
        ctx.fillRect(sx, sy + bandDk + bandLt, cell, bandEarth);
        // Пена (тонкая белая полоса с лёгкой «рваностью»)
        ctx.save();
        ctx.fillStyle = foam;
        const px = 4, py = 2;
        for(let i=0;i<cell;i+=px){
          const jitter = (Math.sin((i+sx)*0.07)*0.5 + Math.random()*0.25) * py;
          ctx.fillRect(sx+i, sy + bandDk + bandLt + bandEarth + jitter, px, bandFoam);
        }
        ctx.restore();
      }

      // ПРАВЫЙ КРАЙ
      if(!map[y][x+1]){
        const sx = (x+1)*cell, sy = y*cell;
        // Тёмно-зелёный кант
        ctx.fillStyle = dkG;
        ctx.fillRect(sx, sy, bandDk, cell);
        // Светло-зелёный кант
        ctx.fillStyle = ltG;
        ctx.fillRect(sx + bandDk, sy, bandLt, cell);
        // Земля
        const g = ctx.createLinearGradient(sx + bandDk + bandLt, 0, sx + bandDk + bandLt + bandEarth, 0);
        g.addColorStop(0, earth);
        g.addColorStop(1, '#6f4424');
        ctx.fillStyle = g;
        ctx.fillRect(sx + bandDk + bandLt, sy, bandEarth, cell);
        // Пена
        ctx.save();
        ctx.fillStyle = foam;
        const px = 2, py = 4;
        for(let j=0;j<cell;j+=py){
          const jitter = (Math.cos((j+sy)*0.09)*0.5 + Math.random()*0.25) * px;
          ctx.fillRect(sx + bandDk + bandLt + bandEarth + jitter, sy + j, bandFoam, py);
        }
        ctx.restore();
      }
    }
  }

  ctx.restore();
}

/* кадр */
function frame(){
  ctx.clearRect(0,0,cw,ch);

  const cam = getCam();
  const wiggle = getWiggleOffset();
  drawIslandUnderShadow(cam, wiggle);
  drawIsland(cam, wiggle);

  requestAnimationFrame(frame);
}

/* resize/init */
function resize(){
  const dpr = window.devicePixelRatio || 1;
  const width = innerWidth;
  const height = innerHeight;
  canvas.style.width = `${width}px`;
  canvas.style.height = `${height}px`;
  canvas.width = Math.round(width * dpr);
  canvas.height = Math.round(height * dpr);
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  cw = width;
  ch = height;
}
addEventListener('resize',resize);
window.addEventListener('storage', (event) => {
  if(event.key === 'map'){
    loadMap();
  }
});
resize();
requestAnimationFrame(frame);
</script>
</body>
</html>
