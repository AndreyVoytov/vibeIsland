<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Scenario Objects</title>
  <style>
    html,body{margin:0;height:100%;overflow:hidden;background:transparent}
    canvas{display:block;position:absolute;top:0;left:0;pointer-events:none;background:transparent}
  </style>
</head>
<body>
<canvas id="scenarioCanvas"></canvas>

<script src="./scenario-objects-config.js"></script>
<script>
const canvas = document.getElementById('scenarioCanvas');
const ctx = canvas.getContext('2d');
let cw = 0;
let ch = 0;

function resize(){
  const dpr = window.devicePixelRatio || 1;
  const width = innerWidth;
  const height = innerHeight;
  canvas.style.width = `${width}px`;
  canvas.style.height = `${height}px`;
  canvas.width = Math.round(width * dpr);
  canvas.height = Math.round(height * dpr);
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  cw = width;
  ch = height;
}
addEventListener('resize', resize);
resize();

let map = [];
let GRID_W = 0;
let GRID_H = 0;
let cellPct = 0;

const scenarioConfig = window.ScenarioObjectsConfig || { objects: [] };
const scenarioObjects = Array.isArray(scenarioConfig.objects) ? scenarioConfig.objects : [];
const scenarioById = new Map(scenarioObjects.map((obj) => [obj.id, obj]));

const COLLIDER_UPDATED_KEY = 'scenarioColliderUpdatedAt';
const COLLIDER_CELLS_KEY = 'scenarioColliderCells';
const SCENARIO_STATE_KEY = 'scenarioObjectsState';
const DIALOGUE_TEXT_KEY = 'scenarioDialogueText';

function loadMap({ initial = false } = {}){
  const parsed = JSON.parse(localStorage.getItem('map') || '[]');
  const nextMap = Array.isArray(parsed) ? parsed : [];
  const nextGridW = nextMap[0]?.length || 0;
  const nextGridH = nextMap.length;
  if(!initial && GRID_W && GRID_H && nextGridW && nextGridH){
    let shift = { x: 0, y: 0 };
    try {
      shift = JSON.parse(localStorage.getItem('mapShift') || '{"x":0,"y":0}');
    } catch (err) {
      shift = { x: 0, y: 0 };
    }
    const shiftX = Number.isFinite(shift.x) ? shift.x : 0;
    const shiftY = Number.isFinite(shift.y) ? shift.y : 0;
    if(shiftX || shiftY){
      scenarioState.forEach((state) => {
        state.gridX += shiftX;
        state.gridY += shiftY;
      });
      persistScenarioState();
    }
  }
  map = nextMap;
  GRID_W = nextGridW;
  GRID_H = nextGridH;
  cellPct = GRID_W ? (100 / GRID_W) : 0;
}

function getIslandBounds(){
  let minX = Infinity;
  let minY = Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;
  for(let y = 0; y < GRID_H; y += 1){
    for(let x = 0; x < GRID_W; x += 1){
      if(map[y]?.[x]){
        minX = Math.min(minX, x);
        minY = Math.min(minY, y);
        maxX = Math.max(maxX, x);
        maxY = Math.max(maxY, y);
      }
    }
  }
  if(!Number.isFinite(minX)) return null;
  return { minX, minY, maxX, maxY };
}

function computeInitialPositions(){
  const bounds = getIslandBounds();
  if(!bounds) return [];
  const centerX = Math.round((bounds.minX + bounds.maxX) / 2);
  const centerY = Math.round((bounds.minY + bounds.maxY) / 2);
  const dirMap = {
    east: { x: 1, y: 0 },
    west: { x: -1, y: 0 },
    north: { x: 0, y: -1 },
    south: { x: 0, y: 1 },
    northEast: { x: 1, y: -1 },
    northWest: { x: -1, y: -1 },
    southEast: { x: 1, y: 1 },
    southWest: { x: -1, y: 1 },
  };
  return scenarioObjects.map((def) => {
    const distance = Number.isFinite(def.distanceCells) ? def.distanceCells : 2;
    const dir = dirMap[def.direction] || dirMap.east;
    const gridX = dir.x === 0
      ? centerX
      : (dir.x > 0 ? bounds.maxX + distance : bounds.minX - distance);
    const gridY = dir.y === 0
      ? centerY
      : (dir.y > 0 ? bounds.maxY + distance : bounds.minY - distance);
    return {
      id: def.id,
      gridX,
      gridY,
      triggered: false,
      transformed: false,
    };
  });
}

function loadScenarioState(){
  let stored = [];
  try {
    stored = JSON.parse(localStorage.getItem(SCENARIO_STATE_KEY) || '[]');
  } catch (err) {
    stored = [];
  }
  if(!Array.isArray(stored)) stored = [];
  const byId = new Map(stored.map((item) => [item.id, item]));
  const initial = computeInitialPositions();
  const next = [];
  scenarioObjects.forEach((def, index) => {
    const existing = byId.get(def.id) || initial[index];
    if(!existing) return;
    next.push({
      id: def.id,
      gridX: Number.isFinite(existing.gridX) ? existing.gridX : 0,
      gridY: Number.isFinite(existing.gridY) ? existing.gridY : 0,
      triggered: Boolean(existing.triggered),
      transformed: Boolean(existing.transformed),
    });
  });
  return next;
}

function persistScenarioState(){
  localStorage.setItem(SCENARIO_STATE_KEY, JSON.stringify(scenarioState));
}

function pct2px(p){ return p * cw / 100; }

function getCam(){ return JSON.parse(localStorage.getItem('camera') || '{"x":0,"y":0}'); }

function getWiggleOffset(){
  const start = Number(localStorage.getItem('islandWiggleAt') || 0);
  if(!start) return { x: 0, y: 0 };
  const duration = 3500;
  const elapsed = performance.now() - start;
  if(elapsed < 0 || elapsed > duration) return { x: 0, y: 0 };
  const t = elapsed / duration;
  const decay = 1 - t;
  const cell = GRID_W ? cw / GRID_W : 0;
  return {
    x: Math.sin(t * Math.PI * 4) * cell * 0.12 * decay,
    y: Math.cos(t * Math.PI * 4) * cell * 0.08 * decay,
  };
}

function getHeroState(){
  return JSON.parse(localStorage.getItem('heroState') || '{"charXPct":50,"charYPct":50,"facing":1,"isMoving":false}');
}

function getHeroGridPosition(){
  if(!cellPct) return null;
  const hero = getHeroState();
  return {
    gridX: Math.floor(hero.charXPct / cellPct),
    gridY: Math.floor(hero.charYPct / cellPct),
    xPct: hero.charXPct,
    yPct: hero.charYPct,
  };
}

const imageCache = new Map();
function getImageRec(url){
  if(!url) return null;
  let rec = imageCache.get(url);
  if(rec) return rec;
  const img = new Image();
  rec = { img, ok: false, loaded: false };
  img.onload = () => { rec.ok = true; rec.loaded = true; };
  img.onerror = () => { rec.ok = false; rec.loaded = true; };
  img.src = url;
  imageCache.set(url, rec);
  return rec;
}

function resolveVisual(def, state){
  if(state.transformed && def.transformOnApproach){
    return {
      assetUrl: def.transformOnApproach.assetUrl || def.assetUrl,
      fallbackUrl: def.transformOnApproach.fallbackUrl || def.fallbackUrl,
    };
  }
  return { assetUrl: def.assetUrl, fallbackUrl: def.fallbackUrl };
}

function shouldUseImage(url){
  return typeof url === 'string' && (url.includes('images') || url.startsWith('data:image'));
}

function isOnLand(state){
  return Boolean(map[state.gridY]?.[state.gridX]);
}

function applyPadding(mapData, padding){
  const width = mapData[0]?.length || 0;
  const padded = mapData.map((row) => {
    const nextRow = row.slice();
    for(let i = 0; i < padding.left; i += 1) nextRow.unshift(0);
    for(let i = 0; i < padding.right; i += 1) nextRow.push(0);
    return nextRow;
  });
  const nextWidth = width + padding.left + padding.right;
  for(let i = 0; i < padding.top; i += 1){
    padded.unshift(Array.from({ length: nextWidth }, () => 0));
  }
  for(let i = 0; i < padding.bottom; i += 1){
    padded.push(Array.from({ length: nextWidth }, () => 0));
  }
  return padded;
}

function getTriggerRadius(def){
  return Number.isFinite(def?.triggerRadiusCells) ? def.triggerRadiusCells : 3;
}

function triggerRadiusTouchesLand(state, radius){
  if(!Number.isFinite(radius)) return false;
  const rounded = Math.max(1, Math.round(radius));
  for(let dy = -rounded; dy <= rounded; dy += 1){
    for(let dx = -rounded; dx <= rounded; dx += 1){
      if(Math.hypot(dx, dy) > radius) continue;
      const checkY = state.gridY + dy;
      const checkX = state.gridX + dx;
      if(map[checkY]?.[checkX]) return true;
    }
  }
  return false;
}

function isHeroWithinTrigger(state, def, heroPos){
  if(!heroPos) return false;
  const radius = getTriggerRadius(def);
  const dx = (state.gridX + 0.5) - heroPos.gridX;
  const dy = (state.gridY + 0.5) - heroPos.gridY;
  return Math.hypot(dx, dy) <= radius;
}

function canSyncTrigger(state, def, heroPos){
  const radius = getTriggerRadius(def);
  if(!triggerRadiusTouchesLand(state, radius)) return false;
  return isHeroWithinTrigger(state, def, heroPos);
}

function spawnScenarioLand(heroPos){
  if(!map.length) return;
  const seeds = [];
  scenarioState.forEach((state) => {
    const def = scenarioById.get(state.id);
    if(!def) return;
    if(state.triggered) return;
    if(!canSyncTrigger(state, def, heroPos)) return;
    seeds.push({ x: state.gridX, y: state.gridY });
  });
  if(!seeds.length) return;

  const width = map[0]?.length || 0;
  const height = map.length;
  const padding = { left: 0, right: 0, top: 0, bottom: 0 };
  seeds.forEach(({ x, y }) => {
    if(x < 0) padding.left = Math.max(padding.left, -x);
    if(y < 0) padding.top = Math.max(padding.top, -y);
    if(x >= width) padding.right = Math.max(padding.right, x - width + 1);
    if(y >= height) padding.bottom = Math.max(padding.bottom, y - height + 1);
  });

  let nextMap = map;
  const shift = { x: 0, y: 0 };
  if(padding.left || padding.right || padding.top || padding.bottom){
    nextMap = applyPadding(nextMap, padding);
    shift.x = padding.left;
    shift.y = padding.top;
  }

  if(shift.x || shift.y){
    scenarioState.forEach((state) => {
      state.gridX += shift.x;
      state.gridY += shift.y;
    });
    seeds.forEach((seed) => {
      seed.x += shift.x;
      seed.y += shift.y;
    });
    persistScenarioState();
  }

  let changed = false;
  seeds.forEach(({ x, y }) => {
    if(nextMap[y]?.[x]) return;
    if(!nextMap[y] || typeof nextMap[y][x] === 'undefined') return;
    nextMap[y][x] = 1;
    changed = true;
  });

  if(!changed && !shift.x && !shift.y) return;

  map = nextMap;
  GRID_W = map[0]?.length || 0;
  GRID_H = map.length;
  cellPct = GRID_W ? (100 / GRID_W) : 0;
  localStorage.setItem('map', JSON.stringify(map));
  localStorage.setItem('mapShift', JSON.stringify(shift));
  rebuildScenarioColliderCells();
}

function drawPrimitive(x, y, w, h, def, floating){
  ctx.save();
  ctx.fillStyle = '#cfd8dc';
  ctx.strokeStyle = '#8a9aa5';
  ctx.lineWidth = 2;
  if(ctx.roundRect){
    ctx.beginPath();
    ctx.roundRect(x - w / 2, y - h / 2, w, h, Math.min(w, h) * 0.2);
    ctx.fill();
    ctx.stroke();
  } else {
    ctx.fillRect(x - w / 2, y - h / 2, w, h);
    ctx.strokeRect(x - w / 2, y - h / 2, w, h);
  }
  if(floating){
    ctx.globalAlpha = 0.6;
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.ellipse(x, y + h * 0.35, w * 0.35, h * 0.18, 0, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.restore();
}

function drawScenarioObject(state, now){
  const def = scenarioById.get(state.id);
  if(!def || !Number.isFinite(state.gridX) || !Number.isFinite(state.gridY)) return;
  const xPct = (state.gridX + 0.5) * cellPct;
  const yPct = (state.gridY + 0.5) * cellPct;
  const baseX = pct2px(xPct);
  const baseY = pct2px(yPct);
  const floating = !isOnLand(state);
  const floatOffset = floating ? Math.sin(now / 600 + state.gridX) * pct2px(cellPct * 0.15) : 0;
  const x = baseX;
  const y = baseY + floatOffset;

  const width = Number.isFinite(def.widthPx) ? def.widthPx : 60;
  const height = Number.isFinite(def.heightPx) ? def.heightPx : 60;

  if(floating){
    ctx.save();
    ctx.globalAlpha = 0.35;
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.ellipse(x, y + height * 0.35, width * 0.4, height * 0.15, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  } else {
    ctx.save();
    ctx.globalAlpha = 0.3;
    ctx.fillStyle = '#1a1a1a';
    ctx.beginPath();
    ctx.ellipse(x, y + height * 0.35, width * 0.35, height * 0.18, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  const visual = resolveVisual(def, state);
  const assetUrl = shouldUseImage(visual.assetUrl) ? visual.assetUrl : '';
  const fallbackUrl = shouldUseImage(visual.fallbackUrl) ? visual.fallbackUrl : '';
  const assetRec = assetUrl ? getImageRec(assetUrl) : null;
  const fallbackRec = fallbackUrl ? getImageRec(fallbackUrl) : null;

  if(assetRec && assetRec.ok && assetRec.loaded){
    ctx.drawImage(assetRec.img, x - width / 2, y - height / 2, width, height);
    return;
  }
  if(fallbackRec && fallbackRec.ok && fallbackRec.loaded){
    ctx.drawImage(fallbackRec.img, x - width / 2, y - height / 2, width, height);
    return;
  }
  drawPrimitive(x, y, width, height, def, floating);
}

let scenarioState = [];
let activeDialogue = null;
let lastDialogueText = '';

function rebuildScenarioColliderCells(){
  const cells = new Set();
  scenarioState.forEach((state) => {
    const def = scenarioById.get(state.id);
    if(!def) return;
    if(!isOnLand(state)) return;
    const radius = Number.isFinite(def.colliderRadius) ? Math.max(1, Math.round(def.colliderRadius)) : 1;
    for(let dy = -radius; dy <= radius; dy += 1){
      for(let dx = -radius; dx <= radius; dx += 1){
        cells.add(`${state.gridX + dx},${state.gridY + dy}`);
      }
    }
  });
  localStorage.setItem(COLLIDER_CELLS_KEY, JSON.stringify([...cells]));
  localStorage.setItem(COLLIDER_UPDATED_KEY, String(Date.now()));
}

function startDialogue(lines){
  if(!Array.isArray(lines) || !lines.length) return;
  activeDialogue = {
    lines,
    index: 0,
    phase: 'show',
    phaseStart: performance.now(),
  };
}

function updateDialogue(now){
  if(!activeDialogue) return;
  const duration = activeDialogue.phase === 'show' ? 3000 : 1000;
  if(now - activeDialogue.phaseStart < duration) return;
  if(activeDialogue.phase === 'show'){
    activeDialogue.phase = 'pause';
    activeDialogue.phaseStart = now;
    return;
  }
  activeDialogue.index += 1;
  if(activeDialogue.index >= activeDialogue.lines.length){
    activeDialogue = null;
    return;
  }
  activeDialogue.phase = 'show';
  activeDialogue.phaseStart = now;
}

function getActiveDialogueText(){
  if(!activeDialogue || activeDialogue.phase !== 'show') return null;
  return activeDialogue.lines[activeDialogue.index];
}

function syncDialogueText(text){
  const next = text || '';
  if(next === lastDialogueText) return;
  lastDialogueText = next;
  localStorage.setItem(DIALOGUE_TEXT_KEY, next);
}

function checkTriggers(){
  if(activeDialogue) return;
  const heroPos = getHeroGridPosition();
  if(!heroPos) return;
  scenarioState.forEach((state) => {
    if(state.triggered) return;
    const def = scenarioById.get(state.id);
    if(!def) return;
    if(!canSyncTrigger(state, def, heroPos)) return;
    if(!isOnLand(state)) return;
    state.triggered = true;
    if(def.transformOnApproach){
      state.transformed = true;
    }
    persistScenarioState();
    rebuildScenarioColliderCells();
    startDialogue(def.dialog || []);
  });
}

function frame(now){
  ctx.clearRect(0, 0, cw, ch);
  const heroPos = getHeroGridPosition();
  spawnScenarioLand(heroPos);
  const cam = getCam();
  const wiggle = getWiggleOffset();
  ctx.save();
  ctx.translate(-cam.x + wiggle.x, -cam.y + wiggle.y);
  scenarioState.forEach((state) => drawScenarioObject(state, now));
  ctx.restore();

  updateDialogue(now);
  checkTriggers();
  const text = getActiveDialogueText();
  syncDialogueText(text);

  requestAnimationFrame(frame);
}

function init(){
  loadMap({ initial: true });
  scenarioState = loadScenarioState();
  persistScenarioState();
  rebuildScenarioColliderCells();
  syncDialogueText(null);
  requestAnimationFrame(frame);
}

window.addEventListener('storage', (event) => {
  if(event.key === 'map'){
    loadMap();
    rebuildScenarioColliderCells();
  }
});

init();
</script>
</body>
</html>
